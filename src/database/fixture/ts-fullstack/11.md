[passport]: https://www.passportjs.org/
[jsonwebtoken]: https://github.com/auth0/node-jsonwebtoken
[ioredis]: https://github.com/redis/ioredis
[cookies-next]: https://github.com/andreizanik/cookies-next
[source]: https://git.3rcd.com/classroom/ts-fullstack/src/branch/main/chapter11

## 导读

:::note

本节课源码: [classroom/ts-fullstack/chapter11][source]（请[登录](https://git.3rcd.com/user/login?redirect_to=%2f)后查看或克隆，否则你将收到**404 NotFound**）

:::

本节课开始讲解与用户认证相关的内容。大致涵盖用户JWT认证、无痛刷新、用户注册、资料修改、用户与文章关联、OAuth2登录、邮箱和手机短信验证等内容。分成多个章节编写，本节课先通过jwt认证与退出登录来实现一个基础的用户认证系统

**请注意：本节课属于填鸭式了，内容非常多，请耐心品读耐心尝试，相信你可以的！**

### 课程目标

由于[next-auth](https://next-auth.js.org/)无法与hono的open实现一个很好的整合，并且对移动端等其它客户端的认证不友好。所以，课程中我们使用[passport.js][passport]作为认证模块来实现认证。本节课的学习目标如下

- 使用[jsonwebtoken][jsonwebtoken]签出jwt token用于用户认证
- 学会使用[ioredis][ioredis]，并使用redis实现token的黑名单机制，用于用户登出
- 增加一个用户认证信息的全局状态
- 实现认证保护路由

### 技术概念

在学习本节前，可以先了解以下内容

- [jwt认证机制](https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html)
- [redis的数据类型](https://www.runoob.com/redis/redis-data-types.html)
- 通过了解[passport.js][passport]在[nestjs中的使用](https://docs.nestjs.com/security/authentication)了解它的策略概念和基本使用

### 前置准备

安装redis，因为我们需要使用redis把退出登录的jwt存入redis黑名单中

:::note

此处仅以macos为例，其它操作系统请方法类似，请自行查找资料

:::

```bash
brew install redis  # 安装redis
brew services start redis # 启动redis，并把redis加入后台服务以开机启动
brew install --cask another-redis-desktop-manager # 一个比较好用的redis gui管理工具
```

安装应用依赖

:::info

因为next.js只能在服务器组件中快速操作cookies，客户端则需要很多代码。[cookies-next][cookies-next]则可以让其在客户端组件或页面中也能快速操作cookies

:::

```bash
pnpm add cookie cookies-next ioredis jsonwebtoken passport passport-local passport-jwt
pnpm add @types/jsonwebtoken @types/passport @types/passport-local @types/passport-jwt -D
```

使用在next.js中用不如bcrypt，所以我们使用node自带的`scrypt`封装用于加密密码和验证密码的两个函数

```ts
// src/libs/passwd.ts
import { randomBytes, scryptSync, timingSafeEqual } from 'node:crypto';

/**
 * 生成密码哈希
 * @param password 原始密码
 * @returns 格式: salt.hash
 */
export const hashPassword = (password: string): string => {
    try {
        // 生成16字节的随机盐值
        const salt = randomBytes(16).toString('hex');
        const hash = scryptSync(password, salt, 64, {
            N: 16384,
            r: 8,
            p: 1,
        }).toString('hex');

        return `${salt}.${hash}`;
    } catch (error) {
        throw new Error(error as any);
    }
};

/**
 * 验证密码
 * @param password 待验证的密码
 * @param storedHash 存储的哈希值（格式：salt.hash）
 * @returns 密码是否正确
 */
export const verifyPassword = (password: string, storedHash: string): boolean => {
    try {
        const [salt, hash] = storedHash.split('.');

        if (!salt || !hash) {
            return false;
        }

        // 使用相同的参数
        const hashVerify = scryptSync(password, salt, 64, {
            N: 16384,
            r: 8,
            p: 1,
        }).toString('hex');

        return timingSafeEqual(Buffer.from(hash), Buffer.from(hashVerify));
    } catch {
        return false;
    }
};
```

### 优化代码

在开始本节课的功能开发之前，我们还需要一些必要的工作以优化前面课程的代码

添加一个把对象里的`Date`类型转换为字符串类型的通用接口类型，解决前后端数据中的`Date`类型问题

```ts
// src/libs/types.ts
/**
 * 将日期类型转换为字符串类型
 */
export type DateToString<T> = {
    [K in keyof T]: T[K] extends Date ? string : T[K];
};
```

为hono路由的openapi添加一个`401`异常响应结构

```ts
// src/server/common/utils.ts
// ...
/**
 * 创建用户未认证响应信息
 * @param description
 */
export const createUnauthorizedErrorResponse = (description?: string) => {
    return createErrorResponse(description ?? '用户未认证', 401);
};
```

在全局应用配置中添加一个`apiUrl`

```ts
// src/libs/types.ts
/**
 * 应用配置
 */
export interface AppConfig {
    baseUrl: string;
    apiUrl: string;
}

// src/config/app.ts
import type { AppConfig } from '@/libs/types';
export const appConfig: AppConfig = {
    baseUrl: process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000',
    apiUrl: process.env.NEXT_PUBLIC_API_URL || `${process.env.NEXT_PUBLIC_BASE_URL}/api`,
};
```

### 时间函数

使用dayjs作为时间工具库

```bash
pnpm add dayjs
```

修改应用配置类型，添加默认时区和默认语言配置

```ts
// src/libs/types.ts
// ...
/**
 * 应用配置
 */
export interface AppConfig {
    baseUrl: string;
    apiUrl: string;
    /**
     * 时区,默认Asia/Shanghai
     */
    timezone?: string;
    /**
     * 语言,默认zh-cn
     */
    locale?: string;
}
```

添加一个时间函数的参数选项类型

```ts
// src/libs/types.ts
// ...
/**
 * getTime函数获取时间的选项参数
 */
export interface TimeOptions {
    /**
     * 时间
     */
    date?: dayjs.ConfigType;
    /**
     * 输出格式
     */
    format?: dayjs.OptionType;
    /**
     * 语言
     */
    locale?: string;
    /**
     * 是否严格模式
     */
    strict?: boolean;
    /**
     * 时区
     */
    timezone?: string;
}
```

编写以下时间工具函数

```ts
// src/libs/time.ts
// ...
import type { Dayjs } from 'dayjs';
import dayjs from 'dayjs';
import 'dayjs/locale/en';
import 'dayjs/locale/zh-cn';
import 'dayjs/locale/zh-tw';
import advancedFormat from 'dayjs/plugin/advancedFormat';
import customParseFormat from 'dayjs/plugin/customParseFormat';
import dayOfYear from 'dayjs/plugin/dayOfYear';
import duration from 'dayjs/plugin/duration';
import localeData from 'dayjs/plugin/localeData';
import localizedFormat from 'dayjs/plugin/localizedFormat';
import timezone from 'dayjs/plugin/timezone';
import utc from 'dayjs/plugin/utc';
import type { TimeOptions } from './types';

dayjs.extend(localeData);
dayjs.extend(utc);
dayjs.extend(timezone);
dayjs.extend(advancedFormat);
dayjs.extend(customParseFormat);
dayjs.extend(localizedFormat);
dayjs.extend(dayOfYear);
dayjs.extend(duration);

// ...
/**
 * 获取全局dayjs对象
 */
export const getDayjs = () => dayjs;

/**
 * 根据传入的参数获取dayjs时间对象
 * @param options
 */
export const getTime = (options?: Pick<TimeOptions, 'date' | 'format' | 'strict'>) => {
    const { date, format, strict } = options ?? {};
    // 每次创建一个新的时间对象
    // 如果没有传入local或timezone则使用应用配置
    return dayjs(date, format, strict).clone();
};

/**
 * 获取当前时区和当前语言的时间
 * @param time
 * @param timezone
 */
export const localTime = (time: Dayjs, options?: Pick<TimeOptions, 'locale' | 'timezone'>) => {
    const locale = options?.locale ?? appConfig.locale;
    const obj = time.tz(options?.timezone ?? appConfig.timezone);
    return !isNil(locale) ? obj.locale(locale) : obj;
};
```

## 应用开发

本节课程的目标是

- 实现用户登录功能
- 在登录后存储token到cookie
- 使用cookie中的token获取用户信息，并设置全局用户信息状态
- 读取cookie中的token，访问受认证保护的api
- 在用户退出后把cookie放入redis黑名单

其基本逻辑如下图

:::info

建议浏览器新标签打开此处，并放大查看

:::

![](https://cn-nb1.rains3.com/3rcd/202411300346179.png)

在开始正式编码之前我们创建一个用于Auth认证功能专用的自定义配置

定义配置类型

```ts
// src/server/auth/types.ts
import type { DurationUnitsObjectType } from 'dayjs/plugin/duration';

/**
 * Auth配置
 */
export interface AuthConfig {
    /**
     * jwt令牌加密秘钥
     */
    jwtSecret: string;
    /**
     * 令牌过期时间,如果是number格式则默认为毫秒
     */
    tokenExpiry: DurationUnitsObjectType | number;
}
```

在`.env`中定义默认jwt加密值的环境变量

```bash
# ...
AUTH_JWT_SECRET="your-secret-key"
```

编写自定义配置

```ts
// src/config/auth.ts
import type { AuthConfig } from '@/server/auth/type';

export const authConfig: AuthConfig = {
    jwtSecret: process.env.AUTH_JWT_SECRET || 'your-secret-key',
    tokenExpiry: { days: 5 },
};
```

### 数据操作

建立数据模型

```json
// src/database/schema/user.prisma
model User {
    id        String   @id @default(uuid())
    username  String   @unique
    email     String   @unique
    password  String
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@map("users")
}
```

执行

```bash
pnpm dbm
pnpm dbg
```

编写测试数据

```ts
// src/database/seed/user.ts
// ...
export const createUserData = async () => {
    await prisma.user.$truncate();
    await prisma.user.create({
        select: { id: true },
        data: {
            username: 'pincman',
            password: hashPassword('12345678aA$'),
            email: 'pincman@example.com',
        },
    });
    for (let index = 0; index < 12; index++) {
        await prisma.user.create({
            select: { id: true },
            data: {
                username: faker.internet.username(),
                password: hashPassword(faker.internet.password()),
                email: faker.internet.email(),
            },
        });
    }
};

// src/database/seed/index.ts
// ...
async function seed() {
    try {
        await createUserData();
        await createPostData();
```

执行

```bash
pnpm dbs
```

编写数据操作函数

```ts
// src/server/auth/service.ts
// ...
/**
 * 验证用户名和密码
 * @param credential 用户名或邮箱
 * @param password 密码
 */
export const validateUser = async (credential: string, password: string) => {
    const user = await db.user.findFirst({
        where: {
            OR: [{ username: credential }, { email: credential }],
        },
        select: {
            id: true,
            username: true,
            email: true,
            password: true,
        },
    });
    if (isNil(user)) return null;
    const isPasswordValid = verifyPassword(password, user.password);
    if (!isPasswordValid) return false;
    const { password: _, ...userWithoutPassword } = user;
    return userWithoutPassword;
};

/**
 * 获取用户
 * @param id 用户ID
 */
export const getUser = async (id: string) => {
    return db.user.findUnique({ where: { id } });
};
```

### 用户登录

首先，编写一下前端表单和后端数据验证共用验证结构体

```ts
// src/server/auth/schema.ts
// ...
/**
 * 登录请求数据结构
 */
export const authLoginRequestSchema = z.object({
    credential: z.string().min(1, '用户名或邮箱不能为空'),
    password: z.string().min(8, '密码至少8位'),
});

/**
 * 登录响应数据结构
 */
export const authLoginResponseSchema = z.object({
    token: z.string(),
});

/**
 * 用户数据结构
 */
export const authItemSchema = z.object({
    id: z.string(),
    username: z.string(),
    email: z.string().email(),
    createdAt: z.coerce.date(),
    updatedAt: z.coerce.date(),
});
```

以及通过它们推导的类型

```ts
// src/server/auth/types.ts
// ...
export type AuthLoginRequest = z.infer<typeof authLoginRequestSchema>;
export type AuthLoginResponse = z.infer<typeof authLoginResponseSchema>;
export type AuthItem = z.infer<typeof authItemSchema>;
```

创建openapi路由配置

```ts
// src/server/auth/routes.ts
// ...
export const authTags = ['认证操作'];

export const authRoutes = {
    // 用户登录
    loginRoute: createRoute({
        tags: authTags,
        method: 'post',
        summary: '用户登录',
        path: '/login',
        request: createBodyRequest(authLoginRequestSchema.openapi('登录请求数据')),
        responses: {
            ...createValidatorErrorResponse(),
            ...createSuccessResponse('登录成功', authLoginResponseSchema),
            ...createUnauthorizedErrorResponse('认证失败'),
            ...createServerErrorResponse(),
        },
    }),
};
```

编写一个使用[jsonwebtoken][jsonwebtoken]生成token令牌的函数

```ts
// src/libs/token.ts
// ...
import jwt from 'jsonwebtoken';
import type { DurationUnitsObjectType } from 'dayjs/plugin/duration';

/**
 * 生成jwt token
 * @param user 用户信息
 */
export const generateAccessToken = (user: AuthItem) => {
    const tokenExpiry: DurationUnitsObjectType = isNumber(authConfig.tokenExpiry)
        ? { seconds: authConfig.tokenExpiry }
        : authConfig.tokenExpiry;
    // 使用ms解析token有效时间
    const expiryMs = getDayjs().duration(tokenExpiry).asMilliseconds();
    return jwt.sign(
        {
            id: user.id,
            username: user.username,
            // 当前时间+token有效时间 = 过期时间
            exp: localTime(getTime().add(expiryMs, 'millisecond')).unix(),
        },
        authConfig.jwtSecret,
    );
};
```

因为我们课程中的用户认证模块使用的上是[passport.js][passport]，所以，需要在先创建一个实例，并编写一个hono中间件对其进行初始化

```ts
// src/server/auth/utils.ts
import type { Context, Next } from 'hono';

import { Passport } from 'passport';
export const passport = new Passport();
/**
 * 初始化passport中间件
 */
export const passportInitialize = () => async (c: Context, next: Next) => {
    const handler = passport.initialize();
    await new Promise((resolve) => {
        handler(c.req.raw as any, (c.res as any).raw, resolve as any);
    });
    await next();
};
```

在`createHonoApp`中运行加上以上中间件函数初始化passport

```ts
// src/server/common/utils.ts
// ...
export const createHonoApp = <E extends Env>(config: HonoAppCreateOptions<E> = {}) => {
    // ...
    app.use('*', passportInitialize());
    return app;
};
```

编写[passport][passport]的本地策略，用于验证数据库中用户的`username`/`email`+`password`的正确性

```ts
// src/server/auth/utils.ts
// ...
import { Strategy as LocalStrategy } from 'passport-local';
/**
 * 添加本地用户认证策略
 */
passport.use(
    'local',
    new LocalStrategy({ usernameField: 'credential' }, async (credential, password, done) => {
        try {
            const user = await validateUser(credential, password);
            if (typeof user === 'boolean' && !user) done({ message: '密码错误', code: 401 });
            if (isNil(user)) done({ message: '用户不存在', code: 401 });
            done(null, user as any);
        } catch (error) {
            done(error);
        }
    }),
);
```

现在我们来编写用户的登录的api处理器

```ts
// src/server/auth/api.ts
// ...
import { passport } from './utils';
const app = createHonoApp();
export const authApi = app.openapi(authRoutes.loginRoute, async (c) => {
    const body = await c.req.json();

    // 手动构建认证请求
    const authReq = {
        ...c.req.raw,
        body,
    };
    return new Promise((resolve) => {
        passport.authenticate('local', (err: any, user: AuthItem, _info: any) => {
            if (err)
                return err.code === 401
                    ? resolve(c.json(createErrorResult('认证失败', err.message), 401))
                    : resolve(c.json(createErrorResult('服务器错误', err), 500));
            const token = generateAccessToken(user);
            return resolve(c.json({ token }, 200));
        })(authReq, (c.res as any).raw);
    });
});
```

在`src/server/main.ts`中添加Auth的API

```ts
// src/server/main.ts
// ...
const routes = app.route('/posts', postApi).route('/auth', authApi);
```

然后编写前端部分，首先，编写一下前端的表单验证和表单处理器

```ts
// src/app/_components/auth/hooks.ts
// ...
/**
 * 创建登录表单
 */
export const useAuthLoginForm = () => {
    const defaultValues = {
        credential: '',
        password: '',
    } as DeepNonNullable<AuthLoginRequest>;
    return useForm<AuthLoginRequest>({
        mode: 'all',
        resolver: zodResolver(authLoginRequestSchema),
        defaultValues,
    });
};

/**
 * 创建登录提交处理器
 * @param setAuthError
 */
export const useAuthLoginSubmitHandler = (setAuthError: (error: string | null) => void) => {
    const { toast } = useToast();
    return useCallback(
        async (data: DeepNonNullable<AuthLoginRequest>) => {
            let status: number = 200;
            setAuthError(null);
            try {
                const res = await fetchApi(async (c) =>
                    c.api.auth.login.$post({
                        json: data,
                    }),
                );
                status = res.status;
                if (!res.ok) throw new Error((await res.json()).message);
                const result = await res.json();
                if (!isNil(result.token)) return true;
                setAuthError('获取token失败，请稍后再试');
                return false;
            } catch (error) {
                if (status === 401) {
                    setAuthError((error as Error).message);
                    return false;
                }
                toast({
                    variant: 'destructive',
                    title: '服务器错误',
                    description: (error as Error).message,
                });
                return false;
            }
        },
        [setAuthError],
    );
};
```

编写表单组件

:::note

目前页面均比较丑陋，关于UI方面我们在后续课程慢慢优化

:::

```tsx
// src/app/_components/auth/login-form.tsx
// ...
export const AuthLoginForm: FC = () => {
    const form = useAuthLoginForm();
    const [authEror, setAuthError] = useState<string | null>(null);
    const submitHandler = useAuthLoginSubmitHandler(setAuthError);

    return (
        <Form {...form}>
            <form onSubmit={form.handleSubmit(submitHandler)} className="!tw-mt-4 tw-space-y-3">
                {authEror && (
                    <div
                        className={cn(
                            'tw-p-3 tw-rounded-md',
                            'tw-bg-red-50 tw-border tw-border-red-200',
                            'tw-text-sm tw-text-red-600',
                            'tw-transition-all tw-duration-300',
                        )}
                    >
                        {authEror}
                    </div>
                )}

                <FormField
                    control={form.control}
                    name="credential"
                    render={({ field }) => (
                        <FormItem>
                            <FormControl>
                                <div className="tw-relative">
                                    <User className="tw-absolute tw-left-3 tw-top-1/2 tw-h-4 tw-w-4 -tw-translate-y-1/2 tw-transform tw-text-gray-500" />
                                    <Input
                                        {...field}
                                        className="tw-pl-10"
                                        autoComplete="credential"
                                        placeholder="请输入用户名或邮箱地址"
                                        disabled={form.formState.isSubmitting}
                                    />
                                </div>
                            </FormControl>
                            <FormMessage />
                        </FormItem>
                    )}
                />
                <FormField
                    control={form.control}
                    name="password"
                    render={({ field }) => (
                        <FormItem>
                            <FormControl>
                                <div className="tw-relative">
                                    <Lock className="tw-absolute tw-left-3 tw-top-1/2 tw-h-4 tw-w-4 -tw-translate-y-1/2 tw-transform tw-text-gray-500" />
                                    <Input
                                        {...field}
                                        className="tw-pl-10"
                                        type="password"
                                        autoComplete="password"
                                        placeholder="请输入密码"
                                        disabled={form.formState.isSubmitting}
                                    />
                                </div>
                            </FormControl>
                            <FormMessage />
                        </FormItem>
                    )}
                />
                <Button
                    type="submit"
                    disabled={form.formState.isSubmitting}
                    className="!tw-mt-5 tw-w-full"
                >
                    {form.formState.isSubmitting ? '登录中...' : '登录'}
                </Button>
            </form>
        </Form>
    );
};
```

编写用户登录页面

```tsx
// src/app/(pages)/auth/login/page.tsx
// ...
import $styles from './style.module.css';

export const generateMetadata = async (_: any, parent: ResolvingMetadata): Promise<Metadata> => {
    return {
        title: `用户登录 - ${(await parent).title?.absolute}`,
        description: '用户登录页面',
    };
};

const AuthLoginPage: FC = async () => {
    return (
        <div className="tw-page-container">
            <div className={$styles.item} style={{ flex: 'none' }}>
                <div className="tw-text-center tw-text-xl tw-font-bold">用户登录</div>
                <AuthLoginForm />
            </div>
        </div>
    );
};
export default AuthLoginPage;
```

编写css

```css
/* src/app/(pages)/auth/login/style.module.css */
.item {
    @apply tw-flex tw-flex-col tw-w-auto tw-space-y-8 tw-bg-white/90 dark:tw-bg-black/50 
   !tw-w-full lg:!tw-w-auto tw-mx-auto tw-px-5 tw-py-9 tw-rounded-md tw-shadow-md tw-mt-28;
}
```

访问[http://localhost:3000/auth/login](http://localhost:3000/auth/login)，账户密码输入在`src/database/seed/user.ts`定义的第一个用户

:::success

根据我们前面的代码可以得知账户也可以是邮箱地址

:::

点击登录后可以看到后端可以正常返回token了

![](https://cn-nb1.rains3.com/3rcd/media/1737383120924.png)

### 读取用户

到目前为止，我们还无法利用登录后返回的令牌做任何事情。而我们本节课的目标主要是实现保护路由，比如对于一些操作类的，比如创建文章、更新文章等api，必须用户登录后才能访问。为此，我们需要在登录后前端存储cookie（顺便读取用户信息并设置全局用户信息桩体） -> 通过存储的token去访问一些受Auth保护的路由

首先，需要在每次请求后端api时，携带具有jwt令牌的请求头。根据前面登录功能的实现可知，登录后会返回一个jwt令牌。我们先把这个令牌存储在cookies里面

编写一个对cookies进行读取和存储的函数库。我们需要注意以下特性

- `next/headers`：只有在RSC(`server component`)中，才能使用`next/headers`来读取cookies，但无法操作cookies。只能在route handler或者server actions中才能使用`next/headers`操作cookies。而在CSR(使用`use client`标注的`client component`)中，甚至无法使用`next/headers`读取cookies
- `cookies-next`：这个库只允许CSR读取和操作cookies，在RSC中无效，是一个纯前端库

为此我们得出结论

- 因为站长不想让代码中的后端对前端的操作有任何黏连和瓜葛，所以直接放弃在RSC中操作（设置和删除）cookies，在RSC中仅保留读取功能
- 而在CSR中，使用`cookies-next`对cookies进行读取和操作

为此

- `getCookies`、`hasCookie`、`hasCookie`、`getCookie`这几个读取函数会根据`window`来判断当前调用者是CSR客户端组件还是RSC服务端组件。如果是CSR则使用`cookies-next`读取cookies。如果是RSC则动态导入`next/headers`去读取cookies（因为如果直接在顶部`import`的方式静态导入`next/headers`，则会在客户端组件中报错）
- `setCookie`和`deleteCookie`则只提供给CSR操作。在RSC中调用不会有任何效果

```ts
// src/libs/coolkies.ts
import type { SerializeOptions as CookieSerializeOptions } from 'cookie';

import {
    deleteCookie as deleteClientCookie,
    getCookie as getClientCookie,
    getCookies as getClientCookies,
    hasCookie as hasClientCookie,
    setCookie as setClientCookie,
} from 'cookies-next';

/**
 * 获取所有cookies
 * @param options
 */
export const getCookies = async (options?: CookieSerializeOptions) => {
    if (typeof window === 'undefined') {
        const { cookies } = await import('next/headers');
        return (await cookies()).getAll();
    }
    return getClientCookies(options);
};

/**
 * 判断cookie是否存在
 * @param key
 * @param options
 */
export const hasCookie = async (key: string, options?: CookieSerializeOptions) => {
    if (typeof window === 'undefined') {
        const { cookies } = await import('next/headers');
        return (await cookies()).has(key);
    }
    return hasClientCookie(key, options);
};

/**
 * 获取cookie
 * @param key
 * @param options
 */
export const getCookie = async (key: string, options?: CookieSerializeOptions) => {
    if (typeof window === 'undefined') {
        const { cookies } = await import('next/headers');
        return (await cookies()).get(key)?.value;
    }
    return getClientCookie(key, options);
};

/**
 * 设置cookie
 * @param key
 * @param value
 * @param options
 */
export const setCookie = async (key: string, value: string, options?: CookieSerializeOptions) => {
    if (typeof window !== 'undefined') setClientCookie(key, value, options);
};

/**
 * 删除cookie
 * @param key
 * @param options
 */
export const deleteCookie = async (key: string, options?: CookieSerializeOptions) => {
    if (typeof window !== 'undefined') deleteClientCookie(key, options);
};
```

添加`setAccessToken`函数，用于在cookies中设置登录后返回的令牌，其中

- `ACCESS_TOKEN_COOKIE_NAME`用于设置jwt令牌在cookies中存储的键名
- `getTokenExpirationTime`用来获取一个令牌的过期时间，然后在`setAccessToken`中配置cookie时，让这个前端cookie的生命周期与token在后端的过期时间一样，这样就能让前后端的令牌一起过期失效。流程为先通过token解析出`payload`，然后根据`payload`中的`过期时间 - 当前时间`的方式得出
- `getAccessTokenOptions`用于合并默认的cookie选项和自定义选项

在此之前，我们先，然后在`setAccessToken`中配置cookie。这样的话就可以在后端令牌过期的同时，然后前端存储令牌的cookie一起过期

```ts
// src/libs/token.ts
import type { SerializeOptions as CookieSerializeOptions } from 'cookie';
// ...

type AccessTokenCookieOptions = Pick<
    CookieSerializeOptions,
    'domain' | 'path' | 'secure' | 'sameSite' | 'partitioned' | 'maxAge' | 'httpOnly'
> & {
    name: string;
    value: string;
};
// 存储在cookies中的令牌键名称
export const ACCESS_TOKEN_COOKIE_NAME = 'auth_token';

// ...

/**
 * 根据token获取过期时间
 * @param token
 */
const getTokenExpirationTime = (token: string): number => {
    const payload = jwt.decode(token) as any;
    if (!isNil(payload?.exp)) {
        const expiresIn = Number(payload.exp) - Math.floor(Date.now() / 1000);
        if (expiresIn <= 0) {
            throw new Error('令牌已过期');
        }
        return expiresIn;
    }
    throw new Error('令牌解析错误');
};

/**
 * 获取access token的cookie选项
 * @param token
 */
const getAccessTokenOptions = (token: string): AccessTokenCookieOptions => {
    const maxAge = getTokenExpirationTime(token);
    return {
        name: ACCESS_TOKEN_COOKIE_NAME,
        value: token,
        maxAge,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'lax',
        path: '/',
    };
};

/**
 * 在cookies设置access token
 * @param token
 */
export const setAccessToken = async (token: string) => {
    const options = getAccessTokenOptions(token);
    await setCookie(options.name, token, omit(getAccessTokenOptions(token), ['name', 'value']));
};
```

现在，可以在用户登录后存储设置一下cookie来存储令牌了。这里我们添加一个登录后跳转到首页的功能

```ts
// src/app/_components/auth/hooks.ts
// ...
const router = useRouter();
// ...
if (!res.ok) throw new Error((await res.json()).message);
const result = await res.json();
if (!isNil(result.token)) {
    setAccessToken(result.token);
    router.replace(`/`);
    return true;
}
```

安装chrome的[Cookie Manager](https://chromewebstore.google.com/detail/cookie-manager/okckmdcaaieknndlpbpjjnfmbakdjnbe?hl=zh-TW&sid=41GT1P)插件，并重新登录一下，查看cookie

![](https://cn-nb1.rains3.com/3rcd/media/1737383785913.png)

在请求时读取cookies中的令牌，并在所有请求的请求头中中加上令牌

```ts
// src/libs/api.ts
// ...
/**
 * 获取通用请求头配置
 * 如果有传入getToken参数,则执行getToken函数获取jwt令牌,并在请求头中加上
 * @param getToken
 */
const getHeadersWithAccessToken = (
    getToken?: () => CookieValueTypes | Promise<CookieValueTypes>,
) => {
    return async () => {
        const headers: Record<string, string> = {};
        if (!isNil(getToken)) {
            const token = await getToken();
            if (!isNil(token) && token.length) {
                headers.Authorization = `Bearer ${token}`;
            }
        }
        return headers;
    };
};

/**
 * 在服务端组件中创建hono api客户端
 */
const honoApi = hc<AppType>(appConfig.baseUrl, {
    headers: getHeadersWithAccessToken(async () => getCookie(ACCESS_TOKEN_COOKIE_NAME)),
});
```

定义后端用户信息响应路由

```ts
// src/server/auth/schema.ts
// ...
/**
 * 获取用户信息响应数据结构
 */
export const authProfileResponseSchema = z.object({
    result: z.boolean(),
    data: authItemSchema.or(z.null()),
});

// src/server/auth/routes.ts
// ...
export const authRoutes = {
    // 获取用户信息
    profileRoute: createRoute({
        tags: authTags,
        method: 'get',
        summary: '获取用户信息',
        path: '/profile',
        responses: {
            ...createSuccessResponse(
                '获取成功',
                authProfileResponseSchema.openapi('获取用户信息响应数据'),
            ),
            ...createServerErrorResponse(),
        },
    }),
    // 用户登录
    //...
};
```

要使用[passport][passport.js]的jwt策略来验证令牌。首先，需要从令牌中解析出`playload`（即`generateAccessToken`函数中使用`jwt.sign`签出的信息，其中包含用户id、过期时间、用户名）。因为`passport`的jwt策略类默认获取请求头中值的方法与hono的不一样，所以还需要自定义一个从请求头中获取token的函数，并放入jwt策略的配置中

```ts
// src/libs/token.ts
// ...
/**
 * 从请求头中获取token
 * @param req 请求
 */
export const getAccessTokenFromHeader = (req: any): string | null => {
    const authHeader = req.headers.get?.('authorization');
    if (authHeader?.startsWith('Bearer ')) {
        return authHeader.substring(7);
    }
    return null;
};

// src/server/auth/utils.ts
import { Strategy as JwtStrategy } from 'passport-jwt';
// ...
/**
 * 添加jwt验证策略
 */
passport.use(
    'jwt',
    new JwtStrategy(
        {
            jwtFromRequest: getAccessTokenFromHeader,
            secretOrKey: authConfig.jwtSecret,
        },
        async (jwtPayload: AuthItem, done: any) => {
            try {
                return done(null, jwtPayload);
            } catch (error) {
                return done(error, false);
            }
        },
    ),
);
```

现在可以使用jwt策略来验证token了

```ts
// src/server/auth/utils.ts
// ...
/**
 * 验证jwt token的有效性
 * @param c 上下文
 */
export const verifyJWT = async (c: Context) =>
    new Promise<boolean>((resolve) => {
        passport.authenticate('jwt', { session: false }, async (err: any, user: AuthItem) => {
            if (err || !user) {
                resolve(false);
                return;
            }
            // 将用户信息添加到请求中，供后续api处理器使用
            (c.req as any).user = user;
            resolve(true);
        })(c.req.raw, (c.res as any).raw);
    });
```

然后编写API处理器。在处理器中可以通过执行`verifyJWT`函数验证token的有效性，且通过`verifyJWT`函数解析token获得的`playload`并作为简易用户对象追加到请求头中的信息，拿到用户的ID，再根据用户ID查询数据库并最终拿到用户数据响应给前端了

```ts
// src/server/auth/api.ts
// ...
export const authApi = app.openapi(authRoutes.profileRoute, async (c) => {
    try {
        const isAuthenticated = await verifyJWT(c);
        if (!isAuthenticated) return c.json({ result: false, data: null }, 200);
        const { id } = (c.req as any).user as AuthItem;
        const user = await getUser(id);
        if (isNil(user)) return c.json({ result: false, data: null }, 200);
        return c.json({ result: true, data: user }, 200);
    } catch (error) {
        return c.json(createErrorResult('获取用户失败', error), 500);
    }
});
// ...
```

### 路由保护

对于一些需要用户登录后才能操作API，我们通过以下解决方案实现保护

- 创建一个`createAuthenticatedHandler`验证器验证前端是否提交jwt或者jwt是否有效，在有效的情况下才进一步运行该路由的api处理器。如果没有jwt或jwt失效，则返回401异常
- 前端收到401异常直接删除当前cookies中的令牌（如果实在CSR中），并跳转到登录页面

```ts
// src/server/auth/utils.ts
// ...
/**
 * 路由JWT验证保护处理器
 * @param handler
 */
export const createAuthenticatedHandler = <R extends RouteConfig>(
    handler: RouteHandler<R>,
): RouteHandler<R> =>
    (async (c: Parameters<RouteHandler<R>>[0], next: Next) => {
        try {
            const isAuthenticated = await verifyJWT(c);
            if (!isAuthenticated) return c.json(createErrorResult('用户未认证'), 401);
            return await handler(c, next);
        } catch (error) {
            return c.json(createErrorResult(error as any), 500);
        }
    }) as any;
```

前端部分在请求时做一下判断，如果后端返回`401`则跳转页面

```ts
// src/libs/api.ts
import { deleteCookie, getCookie } from './coolkies';
import { redirect } from 'next/navigation';
// ...

const fetchApi = async <F extends (c: ReturnType<typeof hc<AppType>>) => Promise<any>>(
    run: F,
): Promise<ReturnType<F>> => {
    const result = await run(honoApi);
    if (!result.ok && result.status === 401) {
        if (typeof window === 'undefined') {
            redirect('/auth/login');
        } else {
            await deleteCookie(ACCESS_TOKEN_COOKIE_NAME);
            window.location.href = '/auth/login';
            return new Promise(() => {}); // 防止后续代码执行
        }
    }
    return result;
};
```

然后，把文章的增删改api路由处理器用`createAuthenticatedHandler`函数包起来，并为它们的路由添加上`401`的`createUnauthorizedErrorResponse`响应结构

```ts
// src/server/post/api.ts
// ...
   .openapi(
        postRoutes.createRoute,
        createAuthenticatedHandler(async (c) => {
            // ...
        }),
    )
    .openapi(
        postRoutes.updateRoute,
        createAuthenticatedHandler(async (c) => {
            // ...
        }),
    )
    .openapi(
        postRoutes.deleteRoute,
        createAuthenticatedHandler(async (c) => {
            // ...
        }),
    );

// src/server/post/routes.ts
// ...
export const postRoutes = {
    // ...
    createRoute: createRoute({
        tags: postTags,
        method: 'post',
        summary: '创建文章',
        path: '/',
        request: createBodyRequest(getPostItemRequestSchema().openapi('创建的文章数据')),
        responses: {
            ...create201SuccessResponse('创建的文章数据', postItemResponseSchema.or(z.null())),
            ...createValidatorErrorResponse(),
            ...createUnauthorizedErrorResponse('认证失败'),
            ...createServerErrorResponse('创建文章失败'),
        },
    }),
    updateRoute: createRoute({
        tags: postTags,
        method: 'patch',
        summary: '更新文章',
        path: '/:id',
        request: {
            params: postDetailByIdRequestParamsSchema,
            ...createBodyRequest(getPostItemRequestSchema().openapi('文章更新数据')),
        },
        responses: {
            ...createSuccessResponse('更新后的文章数据', postItemResponseSchema.or(z.null())),
            ...createValidatorErrorResponse(),
            ...createUnauthorizedErrorResponse('认证失败'),
            ...createServerErrorResponse('更新文章失败'),
        },
    }),
    deleteRoute: createRoute({
        tags: postTags,
        method: 'delete',
        summary: '删除文章',
        path: '/:id',
        request: {
            params: postDetailByIdRequestParamsSchema,
        },
        responses: {
            ...createSuccessResponse('删除文章结果', postItemResponseSchema.or(z.null())),
            ...createValidatorErrorResponse(),
            ...createUnauthorizedErrorResponse('认证失败'),
            ...createServerErrorResponse('删除文章失败'),
        },
    }),
};
```

现在以删除文章为例，我们通过Cookie Manager把cookie清除掉。然后尝试删除一篇文章试试，页面会跳转到`/auth/login`，在登录后发现又可以正常删除了。创建文章和更新文章也是同理

:::warning

由于站长变现代码的时候顺序比较乱，所以请无视以下图中那个加载图标，这会在本节后面部分“用户状态”时讲到

:::

![](https://cn-nb1.rains3.com/3rcd/media/1737385058743.gif)

### 令牌检测

编写一个用于检测当前token是否有效的函数。根据检测结果就实现一些页面的跳转。比如

- 打开用户登录页面时检测token，如果token有效（能正常获取用户信息）则跳转到首页
- 打开文章创建页面时，如果用户未登录则跳转到用户登录页
- 打开文章更新页面时，如果用户未登录则弹出框中的表单为用户登录表单

检测函数的代码如下

```ts
// src/libs/token.ts
// ...
/**
 * 检测token的有效性(当前用户是否已登录)
 */
export const checkAccessToken = async () => {
    try {
        const res = await fetchApi(async (c) => c.api.auth.profile.$get());
        if (res.ok) {
            const { result, data } = await res.json();
            // 如果用户信息获取失败，则证明没有登录或令牌失效
            if (!result || isNil(data)) {
                // 在客户端组件运行此函数会同时清除token
                await deleteCookie(ACCESS_TOKEN_COOKIE_NAME);
                return null;
            }
            return data;
        }
        return null;
        // eslint-disable-next-line unused-imports/no-unused-vars
    } catch (error: any) {
        // 服务器错误，删除access token
        await deleteCookie(ACCESS_TOKEN_COOKIE_NAME);
        throw new Error('检测用户信息失败');
    }
};
```

修改应用代码，如下

```tsx
// src/app/_components/auth/login-form.tsx
// ...
export const AuthLoginForm: FC = () => {
    const router = useRouter();
    // ...
    useEffect(() => {
        (async () => {
            const auth = await checkAccessToken();
            if (!isNil(auth)) router.replace('/');
        })();
    }, []);
    return (
        // ...
    );
};

// src/app/(pages)/posts/create/page.tsx
// ...
const PostCreatePage: FC = async () => {
    const auth = await checkAccessToken();
    if (isNil(auth)) return redirect('/auth/login');
    return (
        // ...
    );
};

// src/app/(pages)/posts/edit/[item]/page.tsx
// ...
const PostEditPage: FC<{ params: Promise<{ item: string }> }> = async ({ params }) => {
    const auth = await checkAccessToken();
    if (isNil(auth)) return redirect('/auth/login');
    // ...
}
```

效果如下

![](https://cn-nb1.rains3.com/3rcd/media/1737385446413.gif)

### 用户状态

在打开浏览器进入某个页面时，我们需要读取一次用户信息并设置全局的用户状态，这样就可以根据是否登录用户显示一些UI组件（通过）。这就需要编写一个全局组件来实现

:::info

目前我们还没在该next.js应用中使用到zustand等状态管理库，这部分在后续章节讲解，暂时先用`useContext`+`Provider`来管理全局状态

:::

:::success

其实我们也可以使用zustand来实现此处的状态管理，你可以自行研究一下以回顾前面的知识

:::

编写`Auth`组件的状态值类型

```ts
// src/app/_components/auth/types.ts
import { DateToString } from '@/libs/types';
import { AuthItem } from '@/server/auth/type';

/**
 * 用户认证的全局状态类型
 */
export interface AuthContextType {
    auth: DateToString<AuthItem> | null;
    setAuth: (auth: DateToString<AuthItem> | null) => void;
}
```

编写Context

```ts
// src/app/_components/auth/context.tsx
// ...

/**
 * 用户认证的全局状态Context
 */
export const AuthContext = createContext<AuthContextType>({
    auth: null,
    setAuth: (_: DateToString<AuthItem> | null) => {},
});
```

编写用户信息状态包装器组件

在此之前，修改`Spinner`组件，让它可以选择是否显示咖啡图标

```tsx
// src/app/_components/loading/spinner.tsx
export const Spinner: FC<{ className?: string; style?: CSSProperties; icon?: boolean }> = (
    props,
) => {
    const { className, style, icon = true } = props;
    // ...
    return (
        <div className={wrapperClasses} style={style ?? {}}>
            {icon && <div className={classes.container} />}
        </div>
    );
};
```

:::info

在未读取用户登录状态并设置`auth`值的时候，添加一个”加载中“的雪碧图，看上去会更加丝滑

:::

```tsx
//src/app/_components/auth/provider.tsx
'use client';
// ...
const AuthProvider: FC<PropsWithChildren & { value: AuthContextType }> = ({ children, value }) => {
    return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

/**
 * 全局认证状态包装器
 * @param children
 * @returns
 */
export const Auth: FC<PropsWithChildren> = ({ children }) => {
    const { toast } = useToast();
    const [auth, setAuth] = useState<DateToString<AuthItem> | null>(null);
    const [checked, setChecked] = useState(false);
    useEffect(() => {
        (async () => {
            try {
                setChecked(false);
                const data = await checkAccessToken();
                setAuth(data);
            } catch (error) {
                toast({
                    title: '网络连接错误',
                    description: `${(error as Error).message}, 请尝试刷新页面`,
                });
            }
            setChecked(true);
        })();
    }, []);
    const value: AuthContextType = useMemo(() => ({ auth, setAuth }), [auth]);
    console.log(checked);
    return (
        <AuthProvider value={value}>
            {checked ? (
                children
            ) : (
                <Spinner
                    className="tw-rounded-sm tw-bg-white/80 tw-transition-opacity tw-duration-300 dark:tw-bg-black/50"
                    icon={false}
                />
            )}
        </AuthProvider>
    );
};
```

把用户信息和设置用户信息两个状态的获取写成hooks

```ts
// src/app/_components/auth/hooks.ts
// ...
/**
 * 获取认证状态
 */
export const useAuth = () => {
    const { auth } = useContext(AuthContext);
    return auth;
};

/**
 * 设置认证状态
 */
export const useSetAuth = () => {
    const { setAuth } = useContext(AuthContext);
    return useCallback((auth: DateToString<AuthItem> | null) => setAuth(auth), []);
};
```

修改登录表单处理器，在用户登录后设置用户状态并跳转到首页

:::info

有了状态设置，我们就没必要再在登录提交处理函数中返回布尔值值了

:::

```tsx
// src/app/_components/auth/hooks.ts
// ...
export const useAuthLoginSubmitHandler = (setAuthError: (error: string | null) => void) => {
    const { toast } = useToast();
    const setAuth = useSetAuth();
    const router = useRouter();
    return useCallback(
        async (data: DeepNonNullable<AuthLoginRequest>) => {
            let status: number = 200;
            setAuthError(null);
            try {
                const res = await fetchApi(async (c) =>
                    c.api.auth.login.$post({
                        json: data,
                    }),
                );
                status = res.status;
                if (!res.ok) throw new Error((await res.json()).message);
                const result = await res.json();
                if (!isNil(result.token)) {
                    setAccessToken(result.token);
                    const auth = await checkAccessToken();
                    if (!isNil(auth)) {
                        setAuth(auth);
                        router.replace(`/`);
                    } else {
                        deleteCookie(ACCESS_TOKEN_COOKIE_NAME);
                        setAuthError('获取用户信息失败，请重新登录');
                    }
                }
            } catch (error) {
                if (status === 401) {
                    setAuthError((error as Error).message);
                }
                toast({
                    variant: 'destructive',
                    title: '服务器错误',
                    description: (error as Error).message,
                });
            }
        },
        [setAuthError],
    );
};
```

在未登录时，隐藏文章的创建、编辑、删除按钮

```tsx
// src/app/_components/header/tools.tsx
// ...
export const HeaderTools: FC<{ isMobile?: boolean }> = ({ isMobile = false }) => {
    const auth = useAuth();
    return (
        <div className={$styles.tools}>
            <div className="tw-flex">{auth && <PostCreateButton iconBtn={isMobile} />}</div>
            <ShadcnThemeSetting />
        </div>
    );
};

// src/app/_components/post/list.tsx
// ...
export const PostActionButtons: FC<{ id: string }> = ({ id }) => {
    const auth = useAuth();
    return (
        auth && (
            <div className="tw-flex tw-items-center [&>time]:tw-ml-2">
                <PostEditButton id={id} />
                <PostDelete id={id} />
            </div>
        )
    );
};
```

把`Auth`组件包装到应用布局上

```tsx
// src/app/(pages)/layout.tsx
// ...
const AppLayout: FC<PropsWithChildren<{ modal: ReactNode }>> = ({ children, modal }) => (
    <Auth>
        <Theme>
            <div className={$styles.layout}>
                <Header />
                {children}
            </div>
            {modal}
            <Toaster />
        </Theme>
    </Auth>
);
export default AppLayout;
```

### 修改顶栏

目前我们没有一个”用户登录“的按钮，把按钮加载`Header`组件上

首先，我们需要安装shadcn的[avatar](https://ui.shadcn.com/docs/components/avatar)组件

```bash
pnpm addsc avatar
```

然后编写用户登录按钮及登录后的用户菜单组件，并根据用户登录后的全局状态进行判断显示

```tsx
// src/app/_components/header/user.tsx
// ...
import { User } from 'lucide-react';
iimport UserAvatar from './avatar.jpg';
import $styles from './user.module.css';

export const LoginButton: FC<{ iconBtn?: boolean }> = ({ iconBtn }) => {
    return (
        <CNButton
            asChild
            className={cn('tw-ml-auto tw-justify-end', {
                'focus-visible:!tw-ring-0': !iconBtn,
                'tw-rounded-sm': !iconBtn,
            })}
            variant={iconBtn ? 'outline' : 'default'}
            size={iconBtn ? 'icon' : 'default'}
        >
            <Link href="/auth/login">
                <User />
                {!iconBtn && '登录'}
            </Link>
        </CNButton>
    );
};

export const UserAction: FC<{ iconBtn?: boolean }> = ({ iconBtn }) => {
    const auth = useAuth();
    return (
        <div className={cn($styles.user)}>
            {isNil(auth) ? (
                <Suspense>
                    <LoginButton iconBtn={iconBtn} />
                </Suspense>
            ) : (
                <DropdownMenu modal={false}>
                    <DropdownMenuTrigger asChild>
                        <Avatar className={$styles.avatar}>
                            <AvatarImage src={UserAvatar.src} />
                            <AvatarFallback>CN</AvatarFallback>
                        </Avatar>
                    </DropdownMenuTrigger>
                    <DropdownMenuContent
                        align="center"
                        className="tw-w-56 tw-text-center tw-text-stone-500"
                    >
                        <DropdownMenuLabel className="tw-justify-center">
                            我的账户
                        </DropdownMenuLabel>
                        <DropdownMenuSeparator />
                        <DropdownMenuItem>
                            <Link href="#">退出登录</Link>
                        </DropdownMenuItem>
                    </DropdownMenuContent>
                </DropdownMenu>
            )}
        </div>
    );
};
```

编写样式

```css
/* src/app/_components/header/user.module.css */
.user {
    @apply tw-flex tw-gap-4 tw-justify-end tw-items-center;
}

.user .avatar {
    @apply tw-w-10 tw-h-10 tw-block tw-rounded-full tw-p-1 tw-bg-white tw-cursor-pointer tw-duration-200 tw-transition-shadow;

    & img {
        @apply tw-transition-transform tw-duration-200;

        &:hover {
            transform: rotate(360deg);
        }
    }

    &:hover {
        @apply tw-shadow-amber-400  tw-shadow-nylg;
    }
}

.user > .authBtns {
    @apply tw-flex tw-gap-4;
}

.user > .authBtns > .authBtn {
    @apply tw-flex tw-items-center tw-justify-center tw-px-4 tw-py-2 
            tw-rounded-full tw-text-sm tw-font-medium tw-transition-all tw-duration-300 tw-border tw-border-transparent
            hover:tw-shadow-lg hover:tw-scale-105 active:tw-scale-95;
}
```

然后在`Header`的`Tools`组件中引入

```tsx
// src/app/_components/header/index.tsx
// ...
export const HeaderTools: FC<{ isMobile?: boolean }> = ({ isMobile = false }) => {
    const auth = useAuth();
    return (
        <div className={$styles.tools}>
            <div className="tw-flex">{auth && <PostCreateButton iconBtn={isMobile} />}</div>
            <ShadcnThemeSetting />
            <UserAction iconBtn={isMobile} />
        </div>
    );
};
```

### 用户登出

当前我们虽然有了登出按钮，但是并没有实际的登出功能，现在我们来编写这个功能。根据上面的流程图可得，我们通过在登出时，把jwt令牌加入redis中黑名单的方式来实现用户登出功能

先编写redis配置和redis实例

```ts
// src/config/redis.ts
import type { RedisOptions } from 'ioredis';
import { parseInt } from 'lodash';
export const redisConfig: RedisOptions = {
    host: process.env.REDIS_HOST || 'localhost',
    port: parseInt(process.env.REDIS_PORT || '6379'),
    password: process.env.REDIS_PASSWORD || undefined,
    db: parseInt(process.env.REDIS_DB || '0'),
    keyPrefix: 'nextapp:',
};

// src/libs/redis.ts
import { redisConfig } from '@/config/redis';
import Redis from 'ioredis';

export const redis = new Redis(redisConfig);
```

编写黑名单令牌存储函数

:::success

由于Token的黑名单操作涉及到redis，所以请不要放在有前端代码杂糅的`src/libs/token.ts`，否则会报错

:::

```ts
// src/server/auth/utils.ts
import jwt from 'jsonwebtoken';
// ...
// 存储在redis中的令牌黑名单键名称
const BLACKLIST_KEY = 'token:blacklist';
// ...

/**
 * 将token加入黑名单
 * @param token 待加入黑名单的token
 */
export const addTokenToBlacklist = async (token: string): Promise<boolean> => {
    try {
        // 先用decode获取过期时间，不验证签名
        const payload = jwt.decode(token) as any;
        if (isNil(payload?.exp)) return false;

        // 计算剩余时间（秒）
        const timeToExpire = payload.exp - localTime(getTime()).unix();
        if (timeToExpire <= 0) return false; // token已过期，无需加入黑名单

        // 验证token的有效性（签名验证）
        jwt.verify(token, authConfig.jwtSecret);

        // token有效且未过期，加入黑名单
        await redis.set(`${BLACKLIST_KEY}:${token}`, '1', 'EX', timeToExpire);
        return true;
    } catch (error) {
        // token已过期或无效，无需加入黑名单
        if (error instanceof jwt.TokenExpiredError || error instanceof jwt.JsonWebTokenError) {
            return false;
        }
        throw new Error(error as any);
    }
};
```

编写令牌黑名单检测函数

```ts
// src/server/auth/utils.ts
// ...
/**
 * 检查token是否在黑名单中
 * @param token 待检查的token
 */
export const isTokenInBlacklist = async (token: string): Promise<boolean> => {
    try {
        const exists = await redis.exists(`${BLACKLIST_KEY}:${token}`);
        return exists === 1;
    } catch (error) {
        throw new Error(error as any);
    }
};
```

在验证JWT令牌有效性时，也验证该令牌是否在黑名单中。这样，如果令牌在黑名单中，即使它还没有过期也验证失败

```ts
// src/server/auth/utils.ts
// ...
export const verifyJWT = async (c: Context) =>
    new Promise<boolean>((resolve) => {
        passport.authenticate('jwt', { session: false }, async (err: any, user: AuthItem) => {
            if (err || !user) {
                resolve(false);
                return;
            }
            const token = getAccessTokenFromHeader(c.req.raw as any);
            // 检查token是否在黑名单中
            if (token && (await isTokenInBlacklist(token))) {
                resolve(false);
                return;
            }
            // 将用户信息添加到请求中，供后续api处理器使用
            (c.req as any).user = user;
            resolve(true);
        })(c.req.raw, (c.res as any).raw);
    });
```

编写用户登出的路由和API处理器

```ts
// src/server/auth/schema.ts
// ...
/**
 * 登出响应数据结构
 */
export const authLogoutResponseSchema = z.object({
    message: z.string(),
});

// src/server/auth/routes.ts
// ...
export const authRoutes = {
    // ...
    logoutRoute: createRoute({
        tags: authTags,
        method: 'post',
        summary: '用户登出',
        path: '/logout',
        responses: {
            ...createUnauthorizedErrorResponse(),
            ...createSuccessResponse('登出成功', authLogoutResponseSchema.openapi('登出响应数据')),
            ...createServerErrorResponse(),
        },
    }),
};

// src/server/auth/api.ts
// ...
export const authApi = app
    // ...
    .openapi(
        authRoutes.logoutRoute,
        createAuthenticatedHandler(async (c) => {
            try {
                const { id } = (c.req as any).user as AuthItem;
                const success = await addTokenToBlacklist(id);
                // 注意：这里直接返回200就行了。因为反正你是退出成功还是token失效，前端都是跳转到登录页，没有什么区别
                if (!success) return c.json(createErrorResult('用户未登录'), 200);
                return c.json({ message: '登出成功' }, 200);
            } catch (error) {
                return c.json(createErrorResult('登出失败', error), 500);
            }
        }),
    );
```

最后，我们修改一下顶栏用户菜单组件

```tsx
// src/app/_components/header/user.tsx
// ...
export const HeaderUser: FC<{ scrolled: boolean }> = ({ scrolled }) => {
     const setAuth = useSetAuth();
    const router = useRouter();
    const { toast } = useToast();
    const loginOut: MouseEventHandler<HTMLAnchorElement> = useCallback(
        async (e) => {
            e.preventDefault();
            try {
                const res = await fetchApi(async (c) => c.api.auth.logout.$post());
                if (res.ok) {
                    deleteCookie(ACCESS_TOKEN_COOKIE_NAME);
                    setAuth(null);
                    router.push('/auth/login');
                }
            } catch (error) {
                toast({
                    variant: 'destructive',
                    title: '服务器错误,请重试！',
                    description: (error as Error).message,
                });
            }
        },
        [toast],
    );
    return (
        <div className={cn($styles.user)}>
            {/* ... */}
                        <DropdownMenuItem>
                            <Link href="#" onClick={loginOut}>
                                退出登录
                            </Link>
           {/* ... */}
        </div>
    );
};
```

### 生成秘钥

目前我们添加的默认秘钥是`your-secret-key`，这是非常不安全的，所以编写一个秘钥生成命令。此命令既可以手动生成秘钥，也可以在安装时生成

当`.env`或者`.env.当前环境`等文件中已经存在秘钥时，则跳过生成

安装以下工具库

```bash
pnpm add find-up dotenv chalk -D
```

编写一个环境变量加载函数

```ts
// src/libs/env.ts
import type { DotenvParseOutput } from 'dotenv';

import dotenv from 'dotenv';
import { findUpSync } from 'find-up';
import { isNil } from 'lodash';
import { readFileSync } from 'node:fs';
/**
 * 加载.env.*文件中的自定义环境变量
 */
export const loadFileEnvs = (): { file?: string; envs?: DotenvParseOutput } => {
    const envName = process.env.NODE_ENV;
    const file = findUpSync(['.env', `.env.${envName}`]);
    if (!isNil(file)) {
        const envs = dotenv.parse(readFileSync(file));
        return { file, envs };
    }
    return {};
};
```

编写生成秘钥生成命令

```ts
import { loadFileEnvs } from '@/libs/env';
import chalk from 'chalk';
import { isNil } from 'lodash';
import { randomBytes } from 'node:crypto';
import { writeFileSync } from 'node:fs';
import { resolve } from 'node:path';

/**
 * 生成秘钥
 */
function generateFormattedSecret(): string {
    const bytes = randomBytes(32);
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';

    // 生成32个随机字符
    let result = '';
    for (let i = 0; i < 32; i++) {
        const randomIndex = bytes[i] % chars.length;
        result += chars[randomIndex];
    }
    return result.match(/.{4}/g)!.join('-');
}

const { file, envs = {} } = loadFileEnvs();
let envPath = file;
if (isNil(envPath)) {
    envPath = resolve(__dirname, '../../..', 'env');
}

if (!isNil(envs?.AUTH_JWT_SECRET)) {
    console.log(chalk.green('The app key already exists and does not need to be generated!'));
} else {
    envs.AUTH_JWT_SECRET = generateFormattedSecret();
    const newEnvContent = Object.entries(envs)
        .map(([key, value]) => `${key}=${value}`)
        .join('\n');

    writeFileSync(envPath, newEnvContent);
    console.log(chalk.green('App key generated successfully!'));
}

process.exit();
```

在`package.json`中添加脚本

```json
{
    "name": "nextapp",
    "version": "0.1.0",
    "private": true,
    "scripts": {
        // ...
        "postinstall": "pnpm run dbm && pnpm run dbs && pnpm run dbg && pnpm run gs",
        "------------------ app command": "----",
        "gs": "cross-env NODE_OPTIONS='--no-warnings=ExperimentalWarning' ts-node -r tsconfig-paths/register --compilerOptions '{\"module\":\"CommonJS\"}' src/server/auth/generate-secret.ts"
    }
    // ...
}
```

因为目前`.env`中有`AUTH_JWT_SECRET=your-secret-key`，所以运行`pnpm gs`会是这样

![](https://cn-nb1.rains3.com/3rcd/media/1737392828918.png)

删除这个默认秘钥，在此运行`pnpm gs`，可以看到，已经生成了32位的秘钥了

![](https://cn-nb1.rains3.com/3rcd/media/1737393270973.png)

### 最终效果

我们来看一下最终效果

:::success

需要注意的是，本节课只是一个粗略的用户登录、登出、认证判断功能，需要细致化的路还有很长，甚至连swagger的枷锁我们都没弄😄，请各位同学悠着点，慢慢学习，加油！

:::

![](https://cn-nb1.rains3.com/3rcd/media/1737394172410.gif)
