[markdown]: https://markdown.com.cn/
[mdx]: https://mdxjs.com/
[react-md-editor]: https://uiwjs.github.io/react-md-editor/
[md-editor-rt]: https://github.com/imzbf/md-editor-rt
[rehype]: https://github.com/rehypejs/rehype
[remark]: https://github.com/remarkjs/remark
[rehype-prism-plus]: https://github.com/timlrx/rehype-prism-plus
[prism-themes]: https://github.com/PrismJS/prism-themes
[react-use]: https://github.com/streamich/react-use
[next-mdx-remote-client]: https://github.com/ipikuka/next-mdx-remote-client
[source]: https://git.3rcd.com/classroom/ts-fullstack/src/branch/main/chapter7

## 导读

:::note

本节课源码: [classroom/ts-fullstack/chapter7][source]（请[登录](https://git.3rcd.com/user/login?redirect_to=%2f)后查看或克隆，否则你将收到**404 NotFound**）

:::

实现使用mdx/markdown渲染文章内容以及markdown编辑器来编辑文章内容

### 课程目标

本节课的目标如下

- 掌握在next.js使用mdx直接渲染页面
- 掌握在next.js使用mdx动态渲染markdown内容
- 通过[rehype插件][rehype]和[remark插件][remark]的生态以及自己编写插件实现一个自定义的mdx渲染器。渲染器支持语法高亮、代码复制、消息条、Toc目录等功能
- 集成[react-md-editor][react-md-editor]实现mdx编辑器

### 技术概念

以下为本节课所涉及的技术概念

- [markdown][markdown]：一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，Markdown文件的后缀名便是“.md”
- [mdx][mdx]： 一种可以渲染前端组件（react、vue等）markdown编译器
- [react-md-editor][react-md-editor]：一个markdown和mdx编辑器，可以自定义实时预览器为自己的mdx渲染器
- [next-mdx-remote-client][next-mdx-remote-client]: 一个用于next.js的同时支持客户端和服务端组件的mdx渲染器

### 前置准备

在开始本课程前，请务必学习[markdown][markdown]的编写方法，并且粗略的了解一下[mdx][mdx]

## 应用开发

现在就让我们来实现在next.js中进行文章的[markdown][markdown]编辑和阅读功能

### 前置准备

在开始本节课之前，我们先修改一些页面和组件，以方便后续开发

#### Header组件

修改Header组件，并在该组件上放置一个导航栏，然后把文章创建按钮、Logo、主题控制器放在该组件上

编写一个hooks用于监听滚动条位置，在滚动条滚动向下滚动非置顶时，增加`Header`的高度和改变颜色

```ts
// src/libs/broswer.ts
'use client';

import { useEffect, useState } from 'react';

/**
 * 监听滚动条位置
 */
export function useScroll(threshold = 0) {
    const [scrolled, setScrolled] = useState(false);

    useEffect(() => {
        const handleScroll = () => {
            setScrolled(window.scrollY > threshold);
        };

        window.addEventListener('scroll', handleScroll);
        return () => window.removeEventListener('scroll', handleScroll);
    }, [threshold]);

    return scrolled;
}
```

安装shadcn的导航栏组件

```bash
pnpm addsc navigation-menu
```

编写导航栏

:::info

样式文件`nav.module.css`请自行从[源码](https://git.3rcd.com/classroom/ts-fullstack/src/branch/main/chapter7/src/app/_components/header/nav.module.css)中复制

:::

```tsx
// src/app/_components/header/nav.tsx
// ...
import $styles from './nav.module.css';

const items = [
    {
        title: '首页',
        href: '/',
    },
];
export const HeaderNav: FC = () => (
    <div className={$styles.nav}>
        <NavigationMenu className={$styles.menus}>
            <NavigationMenuList>
                {items.map((item) => (
                    <NavigationMenuItem key={item.href} className={cn($styles['menu-item'])}>
                        <Link href={item.href} legacyBehavior passHref>
                            <NavigationMenuLink className={cn(navigationMenuTriggerStyle())}>
                                {item.title}
                            </NavigationMenuLink>
                        </Link>
                    </NavigationMenuItem>
                ))}
            </NavigationMenuList>
        </NavigationMenu>
    </div>
);
```

下载[明亮logo](https://cn-nb1.rains3.com/3rcd/media/1736371064977.png)和[暗黑logo](https://cn-nb1.rains3.com/3rcd/media/1736371127086.png)保存到`src/app/_components/header`目录中，并分别重命名为`logo-light.png`和`logo-dark.png`

修改Logo组件代码，如下

```tsx
// src/app/_components/header/logo.tsx
'use client';
// ...
import LogoDark from './logo-dark.png';
import LogoLight from './logo-light.png';
import $styles from './logo.module.css';

export const HeaderLogo: FC = () => {
    const themeColor = useThemeColor();
    const logo = useMemo(() => (themeColor === 'dark' ? LogoDark : LogoLight), [themeColor]);
    return (
        <div className={cn($styles.logo)}>
            <Link href="/">
                <Image
                    src={logo}
                    alt="logo"
                    sizes="100vw"
                    style={{
                        width: '100%',
                        height: 'auto',
                    }}
                />
            </Link>
        </div>
    );
};
```

样式代码

```css
/* src/app/_components/header/logo.module.css */
.logo {
    @apply tw-flex tw-flex-none tw-items-center tw-max-w-28;
}

.logo > a {
    @apply tw-block tw-w-auto tw-h-auto;
}
```

编写工具栏组件

```tsx
// src/app/_components/header/tools.tsx
// ...
import $styles from './tools.module.css';
export const HeaderTools: FC = () => {
    return (
        <div className={$styles.tools}>
            <PostCreateButton />
            <ShadcnThemeSetting />
        </div>
    );
};
```

样式

```css
/* src/app/_components/header/tools.module.css */
.tools {
    @apply tw-flex tw-gap-4 tw-justify-end tw-items-center;
}
```

编写Header组件，把上面的组件放进去。并判断页面是否处于滚动状态，从而为其添加不同的样式

```tsx
// src/app/_components/header/index.tsx
'use client';
// ...
import { useScroll } from '@/libs/broswer';
import $styles from './styles.module.css';
export const Header: FC = () => {
    const scrolled = useScroll(50);

    return (
        <header
            className={cn($styles.header, 'tw-page-container', {
                [$styles['header-scrolled']]: scrolled,
                [$styles['header-unscrolled']]: !scrolled,
            })}
        >
            <div className={cn($styles.container)}>
                <HeaderLogo />
                <HeaderNav />
                <HeaderTools />
            </div>
        </header>
    );
};
```

样式如下

```css
/* src/app/_components/header/styles.module.css */
.header {
    @apply tw-fixed tw-top-0 tw-w-full tw-z-40  tw-mt-0 tw-bg-white/40 dark:tw-bg-zinc-900/10 tw-transition-[background-color] tw-ease-in-out tw-duration-300;
}

.header-scrolled {
    @apply tw-border-b tw-border-gray-200/40 dark:tw-border-gray-800/40  tw-shadow-md tw-bg-white/80 dark:tw-bg-zinc-900/50 tw-backdrop-blur-md;
}

.header > .container {
    @apply tw-flex tw-h-14 tw-w-full tw-justify-between tw-flex-row tw-mb-0 tw-transition-[height] tw-ease-in-out tw-duration-300;
}

.header-scrolled > .container {
    @apply tw-h-16;
}
```

去除首页和文章展示页中原本的工具条

```tsx
// src/app/(pages)/page.tsx
// ...
const HomePage: FC<{ searchParams: Promise<IPaginateQueryProps> }> = async ({ searchParams }) => {
    // ...
        <div className="tw-page-container">
            {/* <Tools /> */}
            <div className={$styles.list}>

// src/app/(pages)/posts/[item]/page.tsx
// ...
const PostItemPage: FC<{ params: Promise<{ item: string }> }> = async ({ params }) => {
    // ...
    return (
        <div className="tw-page-container">
            {/* <Tools back /> */}
```

效果如下

![](https://cn-nb1.rains3.com/3rcd/media/1736371852690.png)

#### 编辑页面

在前面部分为了演示并行路由和拦截路由的使用，文章编辑页面我们采用了弹出框`modal`来实现。但是从本节课程开始，为了页面结构和代码更清晰，我们把编辑页面改为与文章创建页面一样，直接通过整张页面来展示

修改文章操作表单的一些类型，因为现在创建表单和编辑表单融为一体，所以都是有`setPedding`函数了。并且原本的`create`改成`save`，以更好地表面两者是共用表单

```ts
// src/app/_components/post/types.ts
// ...
/**
 * 文章操作表单组件创建文章操作的参数
 */
export interface PostCreateFormProps {
    type: 'create';
    // /**
    //  * 在文章正在创建时执行一些动画
    //  * @param value
    //  */
    // setPedding?: (value: boolean) => void;
}

/**
 * 文章创建/编辑表单的参数类型
 */
export type PostActionFormProps = (PostCreateFormProps | PostUpdateFormProps) & {
    /**
     * 在文章正在创建时执行一些动画
     * @param value
     */
    setPedding?: (value: boolean) => void;
};

/**
 * 文章保存表单的Ref,配合useImperativeHandle可以在表单外部页面调用表单提交函数
 */
export interface PostActionFormRef {
    save?: (e?: BaseSyntheticEvent) => Promise<void>;
}
```

修改表单组件

```tsx
// src/app/_components/post/action-form.tsx
// ...
export const PostActionForm = forwardRef<PostActionFormRef, PostActionFormProps>((props, ref) => {
    // ...
    useEffect(() => {
        if (!isNil(props.setPedding)) props.setPedding(form.formState.isSubmitting);
    }, [form.formState.isSubmitting]);

    useImperativeHandle(
        ref,
        () => ({
            save: form.handleSubmit(submitHandler),
        }),
        [props.type],
    );

    return (
        <Form {...form}>
            <form onSubmit={form.handleSubmit(submitHandler)} className="tw-space-y-8">
                {/* ... */}
                {/* {props.type === 'update' && (
                    <Button type="submit" disabled={form.formState.isSubmitting}>
                        {form.formState.isSubmitting ? '更新中...' : '保存'}
                    </Button>
                )} */}
            </form>
        </Form>
    );
});
```

编写一个直接用于页面的表单来包装上面的`PostActionForm`

```tsx
// src/app/_components/post/page-form.tsx
'use client';
// ...
/**
 * 对action-form的封装，直接用于文章创建和编辑页面
 * 通过判断post是否为null来决定是创建还是编辑
 * @param props
 */
export const PostPageForm: FC<{ post?: Post }> = ({ post }) => {
    const ref = useRef<PostActionFormRef | null>(null);
    const [pedding, setPedding] = useState(false);
    const changePadding = useCallback((value: boolean) => {
        setPedding(value);
    }, []);
    const savePost = useCallback<MouseEventHandler<HTMLButtonElement>>(async (e) => {
        e.preventDefault();
        ref.current?.save && (await ref.current?.save());
    }, []);
    return (
        <>
            <div className="tw-flex tw-justify-between">
                <Button className="tw-ml-auto" onClick={savePost} disabled={pedding}>
                    {pedding ? '保存中...' : '保存'}
                    <Save />
                </Button>
            </div>
            {!isNil(post) ? (
                <PostActionForm ref={ref} type="update" setPedding={changePadding} item={post} />
            ) : (
                <PostActionForm ref={ref} type="create" setPedding={changePadding} />
            )}
        </>
    );
};
```

删除`src/app/(pages)/posts/create/form.tsx`，因为现在不需要这个文件了，我们使用上面的`PostPageForm`代替

修改创建页面的css样式

```css
/* src/app/(pages)/posts/create/style.module.css */
.item {
    @apply tw-flex tw-flex-auto tw-flex-col tw-space-y-6  tw-bg-white/90 dark:tw-bg-black/80  tw-min-w-full lg:tw-min-w-[60%] !tw-max-w-full tw-px-5 tw-py-3 tw-rounded-md;
}
```

修改文章创建页面

```tsx
// src/app/(pages)/posts/create/page.tsx
// ...
import { PostPageForm } from '@/app/_components/post/page-form';

// ...
<div className={$styles.item}>
    <PostPageForm />
</div>;
export default PostCreatePage;
```

创建一个文章编辑页面

```tsx
// src/app/(pages)/posts/edit/[item]/page.tsx
// ...
import $styles from '../../create/style.module.css';

// 添加动态标记，强制使用 SSR
export const dynamic = 'force-dynamic';

const PostEditPage: FC<{ params: Promise<{ item: string }> }> = async ({ params }) => {
    const { item } = await params;
    if (isNil(item)) return notFound();
    const post = await queryPostItemById(item);
    if (isNil(post)) return notFound();
    return (
        <div className="tw-page-container">
            <div className={$styles.item}>
                <PostPageForm post={post} />
            </div>
        </div>
    );
};
export default PostEditPage;
```

现在可以删除`src/app/(pages)/@modal/post-edit`目录了，因为这里面的页面用不到了

然后，改变文章编辑按钮的链接

```tsx
// src/app/_components/post/edit-button.tsx
// ...
const Button: FC<{ id: string }> = ({ id }) => {
    // ...
    return (
        <CNButton asChild className="tw-mr-3">
            <Link href={`/posts/edit/${id}${getUrlQuery}`}>
                <UserPen />
                编辑
            </Link>
        </CNButton>
    );
};
```

### MDX实现

我们先从[mdx][mdx]入手，学习markdown的渲染。next.js官方支持[mdx][mdx]，需要安装以下依赖来使用

```bash
pnpm add @next/mdx @mdx-js/loader @mdx-js/react && pnpm add @types/mdx -D
```

#### 静态渲染

我们先尝试一下静态渲染。也就是使用[mdx][mdx]来编写next.js页面和组件，这些组件是以`.mdx`结尾的文件。在`.mdx`文件里可以混合编写[markdown][markdown]和react代码。

配置next.js

```typescript
// next.config.ts
import createMDX from '@next/mdx';

const withMDX = createMDX();

const nextConfig: NextConfig = {
    /* config options here */
    reactStrictMode: true, // 开启react严格模式
    pageExtensions: ['js', 'jsx', 'mdx', 'ts', 'tsx'],
};

export default withMDX(nextConfig);
```

根据[官方文档](https://nextjs.org/docs/app/building-your-application/configuring/mdx#add-an-mdx-componentstsx-file)的说明，创建`src/mdx-components.tsx`文件，内容如下

```tsx
// src/mdx-components.tsx
import type { MDXComponents } from 'mdx/types';

export function useMDXComponents(components: MDXComponents): MDXComponents {
    return {
        ...components,
    };
}
```

添加一个用于测试的mdx页面。复制源码中的[src/app/\_components/mdx/content-test.mdx](https://git.3rcd.com/classroom/ts-fullstack/src/branch/main/chapter7/src/app/_components/mdx/content-test.mdx)放入`src/app/(pages)/mdx/content.mdx`。这是一个纯markdown文件，内容大致如下

```markdown
> 随着时间的推移，可能部分内容无法与官方最新版本同步，请自行对比查看，我有空会更新

用于Typescript或ES6+的类验证，基于[validator.js](https://github.com/chriso/validator.js)

[手动验证方法列表](https://github.com/typestack/class-validator#manual-validation)和[验证装饰器列表](https://github.com/typestack/class-validator#validation-decorators)

## class-validator中文文档

// ...
```

编写一个标题组件`src/app/(pages)/mdx/title.tsx`

```tsx
// src/app/(pages)/mdx/title.tsx
// ...
export const MdxTitle: FC = () => <h1>class-validator和class-transformer的中文文档</h1>;
```

mdx相对于纯markdown的好处在于mdx中不仅可以直接跑前端代码（比如react代码），而且 `mdx`和`tsx`可以互导。比如定义一个`title.tsx`组件，然后直接可以在`page.mdx`中导入使用

创建一个`src/app/(pages)/mdx/page.mdx`页面，然后把`src/app/(pages)/mdx/content.mdx`作为模块导入

:::success

注意：`page.mdx`使用`.mdx`结尾，而不是`tsx`

:::

```tsx
// src/app/(pages)/mdx/page.mdx
import { Tools } from '@/app/_components/home/tools';
import $styles from '../posts/[item]/page.module.css';
import Content from './content.mdx';
import { MdxTitle } from './title.tsx';

<div className="tw-page-container">
    <div className={$styles.item}>
        <div className={$styles.content}>
            <header className={$styles.title}>
                <MdxTitle />
            </header>
            <div className={$styles.body}>
                <Content />
            </div>
        </div>
    </div>
</div>;
```

启动应用，并访问[http://localhost:3000/mdx](http://localhost:3000/mdx)，获得如下页面代表mdx被正常渲染

![](https://cn-nb1.rains3.com/3rcd/media/1736377405028.png)

#### 代码高亮

可以看到上图中，默认情况下next.js渲染的mdx是没有代码高亮的。在next.js中实现mdx代码高亮的方法是使用[rehype-prism-plus][rehype-prism-plus]或[rehype-highlight](https://github.com/rehypejs/rehype-highlight)插件，它们分别是基于[prism.js](https://prismjs.com/index.html)和[highlight.js](https://highlightjs.org/)实现的mdx代码高亮插件。以[rehype-prism-plus][rehype-prism-plus]代码代码实现高亮

:::warning

注意：prism不是prisma！prism是代码高亮的一个前端库，prisma是一个数据库ORM，两者完全不是一个东西，不要搞混了

:::

安装以下依赖

```bash
pnpm add rehype-prism-plus prism-themes # rehype-prism-plus是prism代码语法高亮插件；prism-themes是prism皮肤插件，会有很多代码高亮皮肤供选择
```

配置prism插件，`showLineNumbers`用于开启行号显示

```javascript
// next.config.ts
const withMDX = createMDX({
    extension: /\.mdx?$/,
    options: {
        remarkPlugins: [],
        rehypePlugins: [['rehype-prism-plus', { showLineNumbers: true }] as any],
    },
});
// ...
```

添加prsim代码高亮的样式。修改`src/app/(pages)/global.css`，导入一个高亮皮肤并添加一些基本样式

:::info

代码行数显示样式是必须要加的（如果你开启了[rehype-prism-plus][rehype-prism-plus]的代码行数显示功能的话），此部分样式正式复制这个库的[官方文档](https://github.com/timlrx/rehype-prism-plus?tab=readme-ov-file#styling)的，你也可以按自己的喜好更改

:::

```tsx
@import 'prism-themes/themes/prism-one-dark.css';

body {
    color: hsl(var(--foreground));
    background-color: hsl(var(--background));
}

/* 使用firecode最为代码字体. 无论使用自定义皮肤还是还是prism-themes中的皮肤,这里都可以设置为自己喜欢的代码字体 */
code[class*='language-'],
pre[class*='language-'] {
    @apply tw-font-[var(--font-family-code)];
}

/* 代码块基本样式 */

pre {
    overflow: auto;

    @apply tw-max-h-[50rem];

    /* 滚动条样式 */
    &::-webkit-scrollbar {
        @apply tw-w-[0.375rem] tw-h-[0.375rem];
    }

    &::-webkit-scrollbar-thumb {
        @apply tw-rounded-[6px] tw-bg-[color:rgb(187_172_172_/_65.1%)];
    }

    &::-webkit-scrollbar-track-piece {
        @apply tw-bg-black/30;
    }

    &::-webkit-scrollbar-corner {
        @apply tw-bg-transparent;
    }
}

pre[class*='language-'] code {
    @apply tw-float-left tw-p-0 tw-pr-4 tw-pl-0;
}

/* 代码行数显示样式. 无论使用自定义皮肤还是还是prism-themes中的皮肤请务必添加(除非你关闭了'rehype-prism-plus'的行数显示功能) */

.code-highlight {
    float: left; /* 1 */
    min-width: 100%; /* 2 */
}

.code-line {
    display: block;
    padding-right: 16px;
    padding-left: 16px;
    margin-right: -16px;
    margin-left: -16px;
    border-left: 4px solid rgb(0 0 0 / 0%); /* Set placeholder for highlight accent border color to transparent */
}

.code-line.inserted {
    background-color: rgb(16 185 129 / 20%); /* Set inserted line (+) color */
}

.code-line.deleted {
    background-color: rgb(239 68 68 / 20%); /* Set deleted line (-) color */
}

.highlight-line {
    margin-right: -16px;
    margin-left: -16px;
    background-color: rgb(55 65 81 / 50%); /* Set highlight bg color */
    border-left: 4px solid rgb(59 130 246); /* Set highlight accent border color */
}

.line-number::before {
    display: inline-block;
    width: 1rem;
    margin-right: 16px;
    margin-left: -8px;
    color: rgb(156 163 175); /* Line number color */
    text-align: right;
    content: attr(line);
}
```

![](https://cn-nb1.rains3.com/3rcd/media/1736378186966.png)

最后，说明一下，虽然从[官方文档](https://nextjs.org/docs/app/building-your-application/configuring/mdx#add-an-mdx-componentstsx-file)来看，`src/mdx-components.tsx`是固定名称并且必须放在`src`目录下的。但其实并不是这样，对于不同模式，比如，一个应用包含多个静态站点（比如一个`blog`、一个`docs`），也可以按照每个站点的需求自定义MDX组件的包含方式，甚至布局等。具体方法因为我们课程中没有遇到这种情况，站长就不展示了。但你利用搜索工具加上自己的智慧自行实现！

#### 动态渲染

动态渲染也叫”远程渲染“，是使用mdx渲染一个markdown格式的字符串而不是直接渲染`.mdx`的方式来呈现内容。因为目前我们的next.js应用是一个动态站点（即：文章数据是从数据库中读取的，而不是一篇文章一个`.mdx`文件的静态页面），所以只有拥有对数据库中文章内容值就行渲染的能力才能使用mdx呈现文章内容。下面，我们来实现这个功能

安装`next-mdx-remote`，这是[next官方的mdx远程渲染库](https://github.com/hashicorp/next-mdx-remote)

```bash
pnpm add next-mdx-remote
```

编写一个用于动态渲染的组件，与静态渲染一样，实现

- 代码高亮
- 显示代码行号

:::info

与`src/mdx-components.tsx`不同，这个组件的位置和名称是可以随意的

:::

```tsx
// src/app/_components/mdx/default-options.ts
import type { MDXRemoteProps } from 'next-mdx-remote/rsc';

import rehypePrism from 'rehype-prism-plus';

/**
 * 默认mdx配置
 */
export const defaultMdxSerializeOptions: Omit<MDXRemoteProps, 'source'> = {
    options: {
        mdxOptions: {
            rehypePlugins: [[rehypePrism, { showLineNumbers: true, ignoreMissing: true }]],
        },
    },
};

// src/app/_components/mdx/render.tsx
// ...
import { MDXRemote } from 'next-mdx-remote/rsc';
import { defaultMdxSerializeOptions } from './default-options';

/**
 * 动态mdx渲染组件
 */
export const MdxRender: FC<MDXRemoteProps> = async (props) => {
    return (
        <MDXRemote {...(deepMerge(defaultMdxSerializeOptions, props, 'merge') as MDXRemoteProps)} />
    );
};
```

在`turbopack`下，如果上面的组件直接使用会出现无法加载高亮语言的问题，我们需要给`rehype-prism-plus`插件去除与next.js的捆绑，保证其里面的`require`可用。在`next.config.ts`添加`serverExternalPackages`配置选项

:::info

如果不使用turbopack则没有这个问题

:::

```ts
// next.config.ts
// ...
const nextConfig: NextConfig = {
    // ...
    serverExternalPackages: ['next-mdx-remote', 'rehype-prism-plus'],
};

export default withMDX(nextConfig);
```

现在，我们来替换文章中的默认的内容展示，使用mdx去渲染文章内容

```tsx
// src/app/(pages)/default.tsx
// ...
const PostItemPage: FC<{ params: { item: string } }> = async ({ params }) => {
    const { item } = await params;
    const post = await queryPostItem(item);
    if (isNil(post)) return notFound();
    return (
        <div className={$styles.container}>
            //...
                    <div className={$styles.body}>
                        <MdxRender source={post.body} />
                    </div>
                </div>
            </div>
        </div>
    );
};
export default PostItemPage;
```

创建一篇文章，标题填入”class-validator和class-transformer的中文文档“，内容把`src/app/(pages)/markdown/content.mdx`中的复制进去

可以看到，文章展示页面的效果如下图

![](https://cn-nb1.rains3.com/3rcd/media/1736409957861.png)

然后我们编辑该文章，随意放置一个react dom进去。比如在文章内容头部放置以下代码

```tsx
<div style={{ background: 'blue', width: '200px', height: '200px' }}> raact render for mdx </div>
```

可以看到mdx可以渲染react了，这是普通的markdown做不到的

:::note

看到效果后，别忘了重新编辑文章，把这个蓝色的`div`去除

:::

![](https://cn-nb1.rains3.com/3rcd/media/1736410314726.png)

#### 渲染器

上述的动态渲染器还比较原始，只支持了代码高亮和代码行数显示。我们接下来实现一个现实产品中的动态mdx渲染器。他需要支持一些其他常见的功能

比如

1. 支持`use client;`标识的客户端组件（方便替换后续md编辑器的默认渲染器）
2. 实现代码复制和代码块折叠功能
3. 使用`remark-toc`+`rehype-slug`+`rehype-autolink-headings`插件可以实现TOC目录锚链接功能以及标题自链接
4. 使用`remark-gfm`可以得到更丰富的markdown功能

要实现以上第一点，我们需要使用[next-mdx-remote-client][next-mdx-remote-client]来替代`next-mdx-remote`作为底层的渲染器。重要的是以下两个步骤

1. 使用`serialized`手动编译mdx内容
2. 把编译后的内容放到next-mdx-remote-client的水合函数`hydrate`中水合，然后渲染水合后的内容

因为我们不需要静态渲染，且动态渲染使用[next-mdx-remote-client][next-mdx-remote-client]代替`next-mdx-remote`了。为了使应用代码更清晰，所以，在开始之前需要做一些清理工作

```bash
pnpm remove next-mdx-remote
```

修改配置如下

```ts
// next.config.ts
const externals: string[] = ['next-mdx-remote-client'];
if (process.env.TURBOPACK) {
    externals.push('rehype-prism-plus');
}

const nextConfig: NextConfig = {
    reactStrictMode: true, // 开启react严格模式
    serverExternalPackages: externals,
};

export default nextConfig;
```

删除`src/mdx-components.tsx`文件和`src/app/(pages)/mdx`目录

首先，我们来构建渲染器的基本结构，然后在其之上堆插件和组件（一些用现成的，没有好用的现成的就自行编写或通过AI编写后手动修改）

安装[next-mdx-remote-client][next-mdx-remote-client]

```bash
pnpm add next-mdx-remote-client && pnpm add vfile # vfile仅用来标注markdown内容的类型，不用去管它
```

由于该库，目前peer依赖是react18，所以我们忽略react版本警告。在`package.json`中添加以下内容

```json
{
    //...
    "pnpm": {
        "peerDependencyRules": {
            "allowAny": ["react", "react-dom"]
        }
    }
}
```

写一个水合渲染组件作为底层渲染组件，用于

- mdx渲染器的底层渲染处理组件
- 后续markdown编辑器的渲染器

编写必要的类型

```ts
// src/app/_components/mdx/types.ts
import type { HydrateProps, SerializeResult } from 'next-mdx-remote-client';
import type { MDXRemoteProps } from 'next-mdx-remote-client/rsc';
import type { Compatible } from 'vfile';

/**
 * mdx序列化配置
 */
export type MdxSerializeOptions = Omit<MDXRemoteProps, 'source'>;

/**
 * mdx水合配置
 */
export type MdxHydrateOptions = Omit<HydrateProps, 'compiledSource'>;

/**
 * mdx水合组件props
 */
export interface MdxHydrateProps extends MdxHydrateOptions {
    serialized: SerializeResult;
}

/**
 * mdx渲染器组件props
 */
/**
 * mdx渲染器组件props
 */
export interface MdxRnderProps {
    source: Compatible;
    options?: MdxSerializeOptions;
    hydrate?: MdxHydrateOptions;
}
```

删除`src/app/_components/mdx/default-options.ts`

重写一个`src/app/_components/mdx/options/serialize.ts`

```ts
// src/app/_components/mdx/options/serialize.ts
import type { MDXRemoteProps } from 'next-mdx-remote-client/rsc';

import rehypePrism from 'rehype-prism-plus';

/**
 * 默认mdx配置
 */
export const defaultMdxSerializeOptions: Omit<MDXRemoteProps, 'source'> = {
    options: {
        mdxOptions: {
            rehypePlugins: [[rehypePrism, { showLineNumbers: true, ignoreMissing: true }]],
        },
    },
};
```

创建`src/app/_components/mdx/options/hydrate.tsx`，写入默认水合组件配置

```tsx
// src/app/_components/mdx/options/hydrate.tsx
import type { HydrateProps } from 'next-mdx-remote-client';

import { cn } from '../../shadcn/utils';
import $styles from '../hydrate.module.css';

/**
 * 默认mdx水合组件配置
 */
export const defaultMdxHydrateOptions: Omit<HydrateProps, 'compiledSource'> = {
    components: {
        wrapper: ({ children }) => (
            <div className={cn('mdx-preview', $styles.content)}>{children}</div>
        ),
    },
};
```

编写水合组件

```tsx
// src/app/_components/mdx/hydrate.tsx
'use client';
// ...

import { useDeepCompareEffect } from 'react-use';
import $styles from './hydrate.module.css';
import { defaultMdxHydrateOptions } from './options/hydrate';

export const MdxHydrate: FC<MdxHydrateProps> = (props) => {
    const { serialized, ...rest } = props;
    const [content, setContent] = useState<string | null>(null);
    const options = useMemo(() => deepMerge(defaultMdxHydrateOptions, rest, 'merge'), [rest]);
    useDeepCompareEffect(() => {
        const { content, error } = hydrate({ ...serialized, ...options } as HydrateProps);
        if (!error && !isNil(content)) setContent(content);
    }, [serialized, options]);
    if (isNil(serialized) || 'error' in serialized) return null;
    return (
        !isNil(content) && (
            <div className={$styles.container}>
                <div className={$styles.article}>{content}</div>
            </div>
        )
    );
};
```

编写水合组件的css样式

```css
/* src/app/_components/mdx/hydrate.module.css */
.container {
    @apply tw-w-full tw-flex tw-gap-8;

    & > .article {
        @apply tw-flex-1 tw-min-w-0 tw-overflow-hidden;
    }

    & > .toc {
        @apply tw-w-56 tw-flex-shrink-0 tw-sticky tw-top-16 tw-self-start;
    }
}
```

把`src/app/(pages)/global.css`中的代码高亮样式移动到`src/app/_components/mdx/styles/rehype-prism.css`中

:::info

用`mdx-preview`包住，以免和后续的md编辑器样式冲突

:::

```css
/* src/app/(pages)/global.css */
body {
    color: hsl(var(--foreground));
    background-color: hsl(var(--background));
}

/* src/app/_components/mdx/styles/rehype-prism.css */

.mdx-preview {
    /* 使用firecode最为代码字体. 无论使用自定义皮肤还是还是prism-themes中的皮肤,这里都可以设置为自己喜欢的代码字体 */
    code[class*='language-'],
    pre[class*='language-'] {
        @apply tw-font-[var(--font-family-code)];
    }
    /* ...其余代码高亮和行数显示样式 */
}
```

在`src/app/_components/mdx/styles/index.css`中导入`src/app/_components/mdx/styles/rehype-prism.css`，并编写一些mdx页面的样式

:::info

具体代码请直接复制[源码](https://git.3rcd.com)

:::

```css
/* src/app/_components/mdx/styles/index.css */
@import './rehype-prism.css';

.mdx-preview {
    /* 链接样式 */
    a {
        @apply tw-text-blue-800/70 hover:tw-text-blue-700/80 dark:tw-text-blue-300/70 dark:hover:tw-text-blue-200/80 tw-mx-0.5 tw-transition-colors tw-duration-200;
    }
    /* ... */
}
```

在水合组件中导入该样式文件

```tsx
// src/app/_components/mdx/hydrate.tsx
'use client';

import './styles/index.css';

// ...

export const MdxHydrate: FC<MdxHydrateProps> = (props) => {
    // ...
};
```

前面我们的渲染器是直接通过`MDXRemote`渲染markdown内容的。而`MDXRemote`内部是`序列化mdx内容` -> `在服务器组件中呈现`的步骤渲染mdx内容的。为了能在客户端组件（比如markdown编辑器的预览界面）中使用mdx渲染器，所以，现在我们换成了`序列化mdx内容`->`在客户端组件中水合序列化后的内容` -> `在客户端组件中呈现`。上面的`MdxHydrate`做了后面两步，所以我们先做要做第一步，手动`序列化mdx内容`。这就需要编写一个序列化函数，代码如下

:::warning

注意：此处必须要加上`use server;`，因为只有在服务端进行`serialize`时，`rehype-prism-plus`插件才能自动加载全部语言

:::

```ts
// src/app/_components/mdx/utils.ts
'use server';
import type { Compatible } from 'vfile';

import { deepMerge } from '@/libs/utils';
import { serialize } from 'next-mdx-remote-client/serialize';

import type { MdxSerializeOptions } from './types';

import { defaultMdxSerializeOptions } from './options/serialize';

export const serializeMdx = async (source: Compatible, options: MdxSerializeOptions = {}) => {
    const result = await serialize({
        source,
        options: deepMerge(defaultMdxSerializeOptions, options, 'merge') as Omit<
            MdxSerializeOptions['options'],
            'source'
        >,
    });
    return result;
};
```

修改渲染器代码如下

:::note

注意：这个渲染器是服务器组件，你也可以在顶部加上`use server;`以明确，但因为next.js默认就是服务器组件，所以不需要强制必须声明

:::

```tsx
// src/app/_components/mdx/render.tsx
// ...
/**
 * 动态mdx渲染组件
 * @param props
 */
export const MdxRender: FC<MdxRnderProps> = async (props) => {
    const { source, options, hydrate } = props;
    const result = await serializeMdx(source, options ?? {});
    return <MdxHydrate {...(hydrate ?? {})} serialized={result} />;
};
```

#### 代码复制

编写一个rehype，给代码块添加一个外框，在外框上添加上代码复制功能

我们先编写一个包装代码块的插件

:::info

这个插件笔者是用AI写的，我也不会写mdx的插件，所以你也不需要研究代码，直接复制[源码](https://git.3rcd.com)就行了

:::

安装以下依赖

```bash
pnpm add unist-util-visit
```

代码大体如下

```ts
// src/app/_components/mdx/plugins/rehype-code-window.ts
// ...
import type { Element } from 'mdx/types';

import { visit } from 'unist-util-visit';

export const rehypeCodeWindow = () => {
    // ...
};
```

编写一个Hooks用于复制代码

代码复制功能自行写一下比较简单，原理是使用`navigator.clipboard`实现。代码窗口是一个简单的包装器，无需深入研究，直接复制[源码](https://git.3rcd.com/classroom/ts-fullstack/src/branch/main/chapter7/src/app/_components/mdx/hooks/code-window.tsx)就行

```tsx
// src/app/_components/mdx/hooks/code-window.tsx
// ...
/**
 * 代码复制按钮
 * @param param0
 */
export const CopyButton: FC<{ wrapperEl: Element | null }> = ({ wrapperEl }) => {
    const [copied, setCopied] = useState(false);
    const handleClick = useCallback<MouseEventHandler<HTMLButtonElement>>(
        (e) => {
            e.preventDefault();
            if (isNil(wrapperEl)) return;
            const contentEl = wrapperEl.querySelector('.code-content') as HTMLElement;
            if (isNil(contentEl)) return;
            navigator.clipboard.writeText(contentEl.textContent || '');
            setCopied(true);
            setTimeout(() => {
                setCopied(false);
            }, 2000);
        },
        [wrapperEl],
    );
    return (
        <button className="code-copy" type="button" onClick={handleClick}>
            {copied ? 'Copied!' : 'Copy'}
        </button>
    );
};

/**
 * 代码框
 * @param ref
 * @param content
 */
export const useCodeWindow = (ref: RefObject<HTMLDivElement | null>, content: string | null) => {
    // ...
};
```

然后别写对应的样式（仍然直接复制[源码](https://git.3rcd.com/classroom/ts-fullstack/src/branch/main/chapter7/src/app/_components/mdx/styles/rehype-code-window.css)）

```css
/* src/app/_components/mdx/styles/rehype-code-window.css */
/* ... */
```

在主样式中导入这个css文件

```css
/* src/app/_components/mdx/styles/index.css */
@import './rehype-prism.css';
@import './rehype-code-window.css';

.mdx-preview {
    /* ... */
}
```

加上插件和hooks，查看效果

```tsx
// src/app/_components/mdx/options/serialize.ts
// ...
export const defaultMdxSerializeOptions: Omit<MDXRemoteProps, 'source'> = {
    options: {
        mdxOptions: {
            rehypePlugins: [
                [rehypePrism, { showLineNumbers: true, ignoreMissing: true }],
                rehypeCodeWindow,
            ],
        },
    },
};

// src/app/_components/mdx/hydrate.tsx
// ...
export const MdxHydrate: FC<MdxHydrateProps> = (props) => {
    // ...
    const contentRef = useRef<HTMLDivElement>(null);
    useCodeWindow(contentRef, content);
    if (isNil(serialized) || 'error' in serialized) return null;
    return (
        !isNil(content) && (
            <div className={$styles.container}>
                <div className={$styles.article} ref={contentRef}>
                    {content}
                </div>
            </div>
        )
    );
};
```

效果如下

![](https://cn-nb1.rains3.com/3rcd/media/1736582539252.gif)

#### 标题锚链接

使用`rehypeSlug`和`rehypeAutolinkHeadings`可以实现标题自身的锚链接

安装依赖

```bash
pnpm add rehype-slug rehype-autolink-headings
```

添加插件

```ts
// src/app/_components/mdx/options/serialize.ts
// ...
import rehypePrism from 'rehype-prism-plus';
import rehypeSlug from 'rehype-slug';

export const defaultMdxSerializeOptions: Omit<MDXRemoteProps, 'source'> = {
    options: {
        mdxOptions: {
            rehypePlugins: [
                rehypeSlug,
                [rehypeAutolinkHeadings, { behavior: 'append' }],
                [rehypePrism, { showLineNumbers: true, ignoreMissing: true }],
                rehypeCodeWindow,
            ],
        },
    },
};
```

加上以下css以显示效果

:::note

前面已加，无需理会

:::

```css
/* src/app/_components/mdx/styles/index.css */
.mdx-preview {
    /* ... */
    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
        @apply tw-scroll-mt-24;

        & > a {
            @apply after:tw-text-slate-700 dark:after:tw-text-slate-300;
        }

        &:hover {
            & > a {
                @apply after:tw-content-['#'];
            }
        }
    }
}
```

查看页面，可以看到鼠标移动到标题上就会出现“#”链接

![](https://cn-nb1.rains3.com/3rcd/media/1736582576321.png)

添加页面滚动效果，这样可以在

- 点击锚链接时，滚动到这个标题，而不是直接跳过去
- 在第一次打开页面的锚链接时，也能滚动到相关标题

首先，在`global.css`添加滚动条缓慢滚动效果

```css
/* src/app/(pages)/global.css */
html {
    @apply tw-scroll-smooth;
}
/* ... */
```

然后，在水合渲染组件中添加一个页面挂载（第一次渲染）时的锚点滚动效果

:::note

注意：`useMount`也可以用react自带的`useEffect`代替

:::

```tsx
// src/app/_components/mdx/hydrate.tsx
// ...
import { useDeepCompareEffect, useMount } from 'react-use';
export const MdxHydrate: FC<MdxHydrateProps> = (props) => {
    // ...
    useMount(() => {
        // 确保页面完全加载
        if (typeof window !== 'undefined') {
            // 获取当前URL的hash
            const hash = decodeURIComponent(window.location.hash);
            if (hash) {
                // 延迟执行以确保DOM已完全渲染
                setTimeout(() => {
                    const element = document.querySelector(hash);
                    if (element) {
                        element.scrollIntoView({ behavior: 'smooth' });
                    }
                }, 100);
            }
        }
    });
    // ...
};
```

查看一下效果

![](https://cn-nb1.rains3.com/3rcd/media/1736641261325.gif)

![](https://cn-nb1.rains3.com/3rcd/media/1736641319908.gif)

#### 消息条

接下来我们实现[docusarurus](https://docusaurus.io/docs/markdown-features/admonitions)一样的`admonitions`效果

我们通过[remark-directive](https://github.com/remarkjs/remark-directive)这个remark插件+AI去实现

:::info

[remark-directive](https://github.com/remarkjs/remark-directive)插件用于实现自定义内容，不仅可以实现admonitions这种alert效果，也可以实现插入B站视频等功能，这些功能留待大家自己实现（后续有需要我也会在课程里追加）

:::

安装依赖

```bash
pnpm add remark-directive
```

根据remark-directive的API使用AI编写一个[remarkAdmonitions](https://git.3rcd.com/classroom/ts-fullstack/src/branch/main/chapter7/src/app/_components/mdx/plugins/remark-admonitions.ts)插件和[Admonition](https://git.3rcd.com/classroom/ts-fullstack/src/branch/main/chapter7/src/app/_components/mdx/components/admonition.tsx)实现`admonitions`效果，具体代码就不演示了，自行复制源码即可

插件代码大致如下

```ts
// src/app/_components/mdx/plugins/remark-admonitions.ts
// ...
const remarkAdmonitions = () => {
    return (tree: any, file: any) => {
        // ...
    };
};
export default remarkAdmonitions;
```

组件代码大致如下

```tsx
// src/app/_components/mdx/components/admonition.tsx
// ...
export const Admonition: FC<AdmonitionProps> = ({ type, title, children }) => {
    // ...
};
interface AdmonitionConfig {
    icon: LucideIcon;
    title: string;
    containerClasses: string;
    iconClasses: string;
    titleClasses: string;
}
```

在serialize的默认配置中引入插件

:::info

请开启`parseFrontmatter`选项，否则无法编译

:::

```ts
// src/app/_components/mdx/options/serialize.ts
// ...
import remarkDirective from 'remark-directive';
import remarkAdmonitions from '../plugins/remark-admonitions';
export const defaultMdxSerializeOptions: Omit<MDXRemoteProps, 'source'> = {
    options: {
        parseFrontmatter: true,
        mdxOptions: {
            remarkPlugins: [remarkDirective, remarkAdmonitions],
            rehypePlugins: [
                //...
            ],
        },
    },
};
```

在hydrate的默认配置中引入组件

```tsx
// src/app/_components/mdx/options/hydrate.tsx
// ...
import { Admonition } from '../components/admonition';
export const defaultMdxHydrateOptions: Omit<HydrateProps, 'compiledSource'> = {
    components: {
        wrapper: ({ children }) => (
            <div className={cn('mdx-preview', $styles.content)}>{children}</div>
        ),
        // 只使用大写的组件名
        Admonition,
    },
};
```

编辑文章，在顶部追加以下内容

```markdown
:::note

note

:::

:::tip

tip

:::

:::info

info

:::

:::warning

warning

:::

:::danger

danger

:::
```

然后查看效果

#### MD语法

默认的编译器不支持删除线，文字加粗等特殊的markdown语法。我们可以通过[remark-gfm](https://github.com/remarkjs/remark-gfm)插件获得支持

安装依赖

```bash
pnpm add remark-gfm
```

添加插件

```ts
// src/app/_components/mdx/options/serialize.ts
// ...
export const defaultMdxSerializeOptions: Omit<MDXRemoteProps, 'source'> = {
    options: {
        parseFrontmatter: true,
        mdxOptions: {
            remarkPlugins: [remarkDirective, remarkAdmonitions, remarkGfm],
            rehypePlugins: [
                // ...
            ],
        },
    },
};
```

在文章顶部添加以下内容

```markdown
~加粗测试~ ~~删除线测试~~ _斜体字测试_
```

效果如下

![](https://cn-nb1.rains3.com/3rcd/media/1736582603558.png)

#### 外链目标

目前文档中所有的链接点击后都会直接在当前页面跳转，很影响体验。我们需要自动为和当前页面非同一个域名的链接添加`target="_blank"`，让它们在新窗口打开。可以使用[rehype-external-links](https://github.com/rehypejs/rehype-external-links)插件解决此问题

安装依赖

```bash
pnpm add rehype-external-links
```

使用插件

```ts
// src/app/_components/mdx/options/serialize.ts
import rehypeExternalLinks from 'rehype-external-links';
// ...

export const defaultMdxSerializeOptions: Omit<MDXRemoteProps, 'source'> = {
    options: {
        parseFrontmatter: true,
        mdxOptions: {
            remarkPlugins: [remarkDirective, remarkAdmonitions, remarkGfm],
            rehypePlugins: [
                [rehypeExternalLinks, { target: '_blank' }],
                // ...
            ],
        },
    },
};
```

编辑文章，在文章内容头部添加以下内容

```markdown
[本地链接](/) [外部链接](https://google.com)
```

效果如下

![](https://cn-nb1.rains3.com/3rcd/media/1736582666662.gif)

#### 文章目录

添加TOC目录，可以让我们更清晰的阅读文章。通过[remark-flexible-toc](https://github.com/ipikuka/remark-flexible-toc)插件即可实现

安装依赖

```bash
pnpm add remark-flexible-toc
```

添加插件

这里需要把`vfileDataIntoScope`设置成`true`。这个插件的作用就是在序列化(`serialize`)之后的结果中，加上一个树形的目录结构数据。有了这个目录树就可以自行写一个目录组件展示目录了

```ts
// src/app/_components/mdx/options/serialize.ts
// ...
export const defaultMdxSerializeOptions: Omit<MDXRemoteProps, 'source'> = {
    options: {
        parseFrontmatter: true,
        vfileDataIntoScope: 'toc',
        mdxOptions: {
            remarkPlugins: [remarkDirective, remarkAdmonitions, remarkGfm, remarkFlexibleToc],
            rehypePlugins: [
                //...
            ],
        },
    },
};
```

修改一些类型

```ts
// src/app/_components/mdx/types.ts
// ...
/**
 * mdx作用域
 */
interface Scope {
    /**
     * toc目录数据
     */
    toc?: TocItem[];
}

/**
 * mdx水合配置
 */
export type MdxHydrateOptions = Omit<HydrateProps, 'compiledSource'> & {
    /**
     * 是否显示toc目录
     */
    toc?: boolean;
};

/**
 * mdx水合组件props
 */
export interface MdxHydrateProps extends MdxHydrateOptions {
    serialized: SerializeResult<Record<string, unknown>, Scope>;
}
```

编写Toc组件

这个组件我是用AI写的，然后再自行一些调整。实现了

- 在浏览器滚动到toc即将被导航栏遮挡时就停止滚动，即“吸顶效果”
- 滚动浏览器的滚动条时，浏览器地址栏中的hash后缀会改成当前滚动位置的标题

请自行复制[toc.tsx](https://git.3rcd.com/classroom/ts-fullstack/src/branch/main/chapter7/src/app/_components/mdx/components/toc.tsx)和[toc.module.css](https://git.3rcd.com/classroom/ts-fullstack/src/branch/main/chapter7/src/app/_components/mdx/components/toc.module.css)放入`src/app/_components/mdx/components`目录中即可。代码大致如下

:::note

因为这个组件主要是AI写的就不分析了，有兴趣自行研究一下

:::

```tsx
// src/app/_components/mdx/components/toc.tsx
'use client';
// ...
interface Props {
    toc: TocItem[];
    maxDepth?: HeadingDepth;
    indented?: boolean;
    ordered?: boolean;
    tight?: boolean;
    exclude?: string | string[];
    skipLevels?: HeadingDepth[];
    skipParents?: Exclude<HeadingParent, 'root'>[];
}

const Toc: FC<Props> = ({
    toc,
    maxDepth = 6,
    ordered = false,
    indented = true, // 将默认值改为true
    tight = false,
    exclude,
    skipLevels = [1],
    skipParents = [],
}) => {
    const [activeId, setActiveId] = useState('');
    const tocListRef = useRef<HTMLUListElement>(null);
    // ...
};

export default Toc;
```

现在，在水合组件中引入TOC查看一下效果

```tsx
// src/app/_components/mdx/hydrate.tsx
// ...
export const MdxHydrate: FC<MdxHydrateProps> = (props) => {
    const { serialized, toc = true, ...rest } = props;
    // ...
    return (
        !isNil(content) && (
            <div className={$styles.container}>
                <div className={$styles.article} ref={contentRef}>
                    {content}
                </div>
                {toc && !isNil(serialized.scope?.toc) && (
                    <div className={$styles.toc}>
                        <Toc toc={serialized.scope.toc} />
                    </div>
                )}
            </div>
        )
    );
};
```

![](https://cn-nb1.rains3.com/3rcd/media/1736657183302.gif)

#### 编辑器

目前，我们只有对markdown/mdx的渲染，没有一个良好的编辑器就不是很方便在线编辑markdown。所以，很多情况下我们喜欢使用typora、obsidian等编辑器，写好内容再放到文章表单的内容框中。但有时，如果临时需要直接在线编写一下markdown，显然有一个在线编辑器会更方便一些。为了实现直接在线编辑文章内容的目的，需要制作一个markdown编辑器。自己手动写一个md编辑器的工程量是巨大的，所以我们直接使用现成的[react-md-editor][react-md-editor]整合到当前的next.js应用中来实现对md文章内容的编辑。

安装依赖

```bash
pnpm add react-md-editor
```

把该组件加入`transpilePackages`中，以防止next.js渲染错误

```ts
// next.config.ts
// ...
const nextConfig: NextConfig = {
    reactStrictMode: true, // 开启react严格模式
    serverExternalPackages: externals,
    transpilePackages: ['@uiw/react-md-editor'],
};

export default nextConfig;
```

编写编辑器组件，其原理为

该编辑器是基于react-md-editor实现的。当props中传入的内容变化时，使用`serializeMdx`序列化内容。然后用我们自己编写的`MdxHydrate`渲染器替代编辑器默认的渲染器，并把序列化后的内容传入渲染器进行渲染

同时，实现以下效果

- 因为在敲击内容时，会不停的执行序列化函数，导致浏览器内存过载。所以我们通过`debounce`函数添加一个防抖效果，每隔1000ms渲染一次。这虽然会让右边的预览窗口每隔1秒变化一次，但有效的减少了大量的浏览器内存消耗
- 通过dynamic的方式动态导入该编辑器，而不是直接静态`import`
- 根据前面课程中的`useThemeColor`获取当前主题颜色，并在编辑器外部的包装div上加上`data-color-mode`用于设置编辑器的颜色。这里，我们可以在编辑器前面加上一个`<div className="wmde-markdown-var"> </div>`来调整编辑器在明暗模式下的颜色css变量（我这边用默认的，有兴趣可自行调整）
- 编辑器的默认高度和最小高度为其外面包装的div的高度，而此高度是根据页面的flex高度自动设置的（通过添加`resize`监听，让其在浏览器大小变化时重置高度）。同时，该编辑器自带一个拖拽拉伸高度和全屏编辑的功能
- 在提交表单时，添加一个蒙版用于禁用编辑器的所有功能以及文字输入

添加一个编辑器组件的props类型

```ts
// src/app/_components/mdx/types.ts
// ...
/**
 * mdx编辑器组件props
 */
export interface MdxEditorProps {
    content?: string;
    setContent: (value?: string) => void;
    disabled?: boolean;
}
```

编辑器组件代码如下

```tsx
// src/app/_components/mdx/editor.tsx
'use client';

import '@uiw/react-md-editor/markdown-editor.css';
import { debounce, isNil } from 'lodash';
import dynamic from 'next/dynamic';
import { type FC, useCallback, useEffect, useRef, useState } from 'react';

import type { MdxEditorProps, MdxHydrateProps } from './types';

import { useThemeColor } from '../theme/hooks';
import $styles from './editor.module.css';
import { MdxHydrate } from './hydrate';
import { serializeMdx } from './utils';

const MDEditor = dynamic(() => import('@uiw/react-md-editor'), { ssr: false });

export const MdxEditor: FC<MdxEditorProps> = (props) => {
    const { content, setContent, disabled } = props;
    const [serialized, setSerialized] = useState<MdxHydrateProps['serialized']>();
    const theme = useThemeColor();
    const containerRef = useRef<HTMLDivElement>(null);
    const [editorHeight, setEditorHeight] = useState<number>();

    // 防抖效果，减少序列化次数
    const debouncedSerialize = useCallback(
        debounce(async (text: string) => {
            const serialized = await serializeMdx(text);
            setSerialized(serialized);
        }, 1000),
        [],
    );

    useEffect(() => {
        if (!isNil(content)) debouncedSerialize(content);
        return () => {
            debouncedSerialize.cancel();
        };
    }, [content]);

    const updateHeight = useCallback(() => {
        if (containerRef.current) {
            const parentHeight = containerRef.current.clientHeight;
            if (parentHeight) {
                setEditorHeight(parentHeight);
            }
        }
    }, [containerRef.current]);

    useEffect(() => {
        if (!isNil(serialized) && isNil(editorHeight)) updateHeight();
        window.addEventListener('resize', updateHeight);
        return () => {
            window.removeEventListener('resize', updateHeight);
        };
    }, [serialized]);

    return (
        serialized && (
            <div ref={containerRef} data-color-mode={theme} className={$styles.container}>
                <div className="wmde-markdown-var"> </div>
                <MDEditor
                    value={content}
                    onChange={setContent}
                    height={editorHeight}
                    minHeight={editorHeight}
                    textareaProps={{ disabled }}
                    visibleDragbar
                    components={{
                        preview: () => <MdxHydrate serialized={serialized} toc={false} />,
                    }}
                />
            </div>
        )
    );
};
```

编写编辑器样式，如下

```css
/* src/app/_components/mdx/editor.module.css */
.container {
    @apply tw-flex tw-flex-auto tw-w-full;

    & > :global(.wmde-markdown-var.w-md-editor) {
        @apply tw-flex-auto tw-w-full;
    }

    & :global(.wmde-markdown-var:has(.w-md-editor-text-input:disabled)) {
        @apply tw-pointer-events-none tw-cursor-not-allowed;

        &::before {
            @apply tw-content-[''] tw-absolute tw-inset-0 tw-z-[99] tw-pointer-events-none tw-rounded-[3px] tw-bg-zinc-300/50 dark:tw-bg-zinc-900/50 tw-backdrop-blur-[2px];
        }

        & > :global(.w-md-editor-content > .w-md-editor-area),
        & > :global(.w-md-editor-content > .w-md-editor-preview) {
            @apply tw-overflow-hidden;
        }
    }
}
```

修改表单组件，引用该编辑器

:::info

为了达到更好的视觉效果，我们可以把可选字段默认折叠，也就是去除`defaultOpen`属性

:::

```tsx
// src/app/_components/post/action-form.tsx
'use client';
// ...
import { MdxEditor } from '../mdx/editor';

export const PostActionForm = forwardRef<PostActionFormRef, PostActionFormProps>((props, ref) => {
    // ...
    const [body, setBody] = useState<string | undefined>(
        props.type === 'create' ? '文章内容' : props.item.body,
    );

    useEffect(() => {
        if (!isNil(body)) form.setValue('body', body);
    }, [body]);


    return (
        <Form {...form}>
            <form
                onSubmit={form.handleSubmit(submitHandler)}
                className="tw-flex tw-flex-auto tw-flex-col tw-space-y-8"
            >
                {/* ... */}
                <Details summary="可选字段" {/* 去除默认的defaultOpen */}>
                    {/* ... */}
                    />
                </Details>
                <FormField
                    control={form.control}
                    name="body"
                    render={({ field: _ }) => (
                        <FormItem className="tw-flex tw-flex-auto tw-flex-col">
                            <FormLabel className="tw-mb-3">文章内容</FormLabel>
                            <FormControl>
                                 <MdxEditor
                                     content={body}
                                     setContent={setBody}
                                     disabled={form.formState.isSubmitting}
                                 />
                                {/* <Textarea
                                    placeholder="请输入内容"
                                    {...field}
                                    className="tw-min-h-80"
                                /> */}
                            </FormControl>
                            <FormMessage />
                        </FormItem>
                    )}
                />
            </form>
        </Form>
    );
});
```

查看效果

![](https://cn-nb1.rains3.com/3rcd/media/1736758577109.gif)

### 并不完美

其实，本节课程有许多地方并不完美。这留待你自己和我们后续课程慢慢进行优化处理。大致包含以下一些问题

#### 响应式适配

目前无论toc文章目录还是导航栏等，整个网站都没实现移动端适配，这将在我们后续课程中再逐步完善

#### 渲染器卡顿

在编写文章内容时，可以看到我们的渲染器有一些卡顿现象会发生。这是因为有许多mdx相关插件在编辑时，不间断的渲染造成的现象。我们前面使用了防抖，只是减少了浏览器的负载，并没有从本质上解决这一现象。如果使用纯markdown的编辑器和渲染器，比如[md-editor-rt](https://imzbf.github.io/md-editor-rt/)这一类，则会好得多。但mdx也为我们带来了更多的丰富特性，具体使用哪种方式渲染，取决于项目本身

#### 编辑器BUG

由于react-md-editor自动加载了`rehype-prism-plus`插件，而next.js在turbopack运行时中，必须使用`serverExternalPackages`才能正常加载这个插件。所以，在开发环境中使用turbopack是无法实现编辑器内高亮的。但在编译后的生产环境运行应用，是正常的。所以这并不会产生太大影响

![](https://cn-nb1.rains3.com/3rcd/media/1736770886386.png)

编译后

![](https://cn-nb1.rains3.com/3rcd/media/1736773181123.png)

#### 其它插件

本节课程由于篇幅有限，所以举例使用了一些常用的mdx渲染插件，事实上还有许多可用的插件。例如，你可以通过[remark插件库](https://github.com/remarkjs/remark/blob/main/doc/plugins.md)以及[rehype插件库](https://github.com/rehypejs/rehype/blob/main/doc/plugins.md)获得更多好用的插件信息
