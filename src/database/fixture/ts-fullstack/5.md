[nextjs]: https://nextjs.org/docs
[fakerjs]: https://fakerjs.dev/guide/
[server-action]: https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations
[route-groups]: https://nextjs.org/docs/app/building-your-application/routing/route-groups
[dynamic-routes]: https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes
[parallel-routes]: https://nextjs.org/docs/app/building-your-application/routing/parallel-routes
[intercepting-routes]: https://nextjs.org/docs/app/building-your-application/routing/intercepting-routes
[rsc]: https://react.dev/reference/rsc/server-components
[react-hook-form]: https://react-hook-form.com
[utility-types]: https://github.com/piotrwitek/utility-types
[react-use]: https://github.com/streamich/react-use
[source]: https://git.3rcd.com/classroom/ts-fullstack/src/branch/main/chapter5

## 导读

:::note

本节课源码: [classroom/ts-fullstack/chapter5][source]（请[登录](https://git.3rcd.com/user/login?redirect_to=%2f)后查看或克隆，否则你将收到**404 NotFound**）

:::

:::info

无论本篇后续的next.js相关章节还是更高级篇章的next.js课程都是基于这节课的应用进行扩展的，所以请务必确保掌握！

:::

本节课开始我们使用两节课的篇幅快速地编写一个简单的丐版next.js全栈应用

### 课程目标

本节课的目标如下

- 使用[next.js][nextjs]编写一个简单的CRUD个人博客网站
- 学会数据分页原理
- 掌握[faker.js][fakerjs]假数据生成方法
- 了解[服务端（rsc）组件][rsc]和客户端组件的区别及用法
- 理解在next.js的[server action][server-action]与全栈开发方案
- 学会[路由组][route-groups]、[动态路由][dynamic-routes]、[并行路由][parallel-routes]的使用（也可以自行学习一下[拦截路由][intercepting-routes]，因为课程中没涉及到，所以可以作为课后任务来学习）
- 更加熟练地编写css和tailwindCSS

### 技术概念

以下为本节课所涉及的技术概念

- [服务端组件][rsc]是一种新的react组件渲染方式。是通过在服务器侧直接渲染好直出给浏览器的组件。用于SSR应用中需要SEO友好或有快速首屏渲染需求且交互不多的页面
- [server action][server-action]是一种全新的开发方案，可以在客户端或服务端组件中直接调用后端服务器node函数（比如数据库操作）的方式。原理上其实在react页面组件调用后端函数时会生成一个类似restful api的Http接口来访问，只不过这些操作[next.js][nextjs]帮我们封装好了而已。所以看上去就是在组件/页面（甚至客户端组件）中直接调用了后端函数
- [react-hook-form][react-hook-form]：一个好用的react表单构建库，shadcn/ui默认使用它
- [micromatch](https://github.com/micromatch/micromatch)：node的[glob](https://www.gulpjs.com.cn/docs/getting-started/explaining-globs/)模糊匹配库
- [utility-types][utility-types]：一个提供许多高阶ts类型的包
- [react-use][react-use]: 一个hooks工具库

### 前置准备

本节课内容非常多，直接跟着走就是了。如果不懂建议查看一下[next.js][nextjs]的官方文档。如果出现错误，请对比[源码](https://git.3rcd.com/classroom/ts-fullstack/src/branch/main/chapter6)来学习。在此之前，我们先删除前面课程的`demo`目录，因为用不到了...

## 需求分析

在开发应用前，我们先对这个项目有个良好的整体规划是一个比较不错的习惯。尽管我们的应用非常mini，但是我们也做一些简单的需求分析

### 功能阐述

以下功能为本篇章课程中实现的next.js+prisma全栈小应用的功能。（其中打✅的功能为本节课实现，打❎的功能为后面几节课实现）。

然而，真正完善的应用，我们留待后续更高级的课程再去扩展实现。后续篇章的课程将会在这个小应用上扩展出一个强大且酷炫的多功能个人网站应用，而本篇的next.js相关章节旨在带领大家大致掌握整个next.js+prisma开发的大部分常用技能和知识点。

- ✅实现一个文章发布、更新、删除、列表分页查询、文章详情查询的一个简单个人博客网站
- ✅项目的基本布局、样式、路由、页面设计
- ✅通过路由组来组建项目的文件结构
- ✅通过动态路由来展示文章详情页
- ✅通过并行路由实现弹出框方式的文章创建与编辑
- ✅掌握使用server action开发next.js全栈应用的基础
- ❎通过prisma orm+sqlite来持久存储和操作数据
- ❎使用prisma对数据进行分页处理
- ❎使数据按“创建时间+更新时间”时间倒序排序（最新数据在前面呈现）
- ❎实现mdx静态页面和静态内容渲染渲染
- ❎实现可视化markdown编辑器来编辑和渲染文章内容
- ❎根据文章关键字、描述以及slug后缀等实现基本的SEO优化
- ❎实现文章读取和创建、编辑时的Loading效果
- ❎实现自定义的404和错误页面以及错误弹出框
- ❎实现文章创建和编辑表单的数据验证

### 路由设计

本节课程的路由非常简单，基本围绕文章的CRUD来设计

:::success

处于简单考虑，在本篇中的next.js应用并不会去单独设计个landing page，所以直接在首页显示文章列表了

:::

| 路由 | 功能 | 介绍 |
| --- | --- | --- |
| `/` | 首页 | 用于显示分页文章列表。为了匹配根路径而忽略首页目录本身，我们需要使用到[路由组][route-groups]。比如`(home)`目录这样的加了两个括号的，next.js会自动在url中忽略。这样就可以通过`/`去访问`(home)`目录下的`page.tsx`，而不是`/home` |
| `/posts/{item}` | 文章详情页 | 用于读取一篇文章的数据。需要实现的效果为，根据id动态显示一篇文章的内容，所以用到[动态路由][dynamic-routes]。另外，如果你也可以尝试一下实现“在文章列表中点击某个文章会像创建文章一样出现一个弹出框来展示该文章，而刷新页面后则只显示该文章的内容页”的效果。这就需要同时用到[并行路由][parallel-routes]和[拦截路由][intercepting-routes]。不过这个不在本节课的范围内，有需要可以自行作为课后作业去实现 |
| `/post-create` 与 `/post-edit` | 文章创建页面和文章编辑页面 | 为了方便快捷创建和编辑文章，此路由设计弹出框式的[并行路由][parallel-routes]。在刷新页面后，这两个页面仍然是弹出框 |

### 项目结构

首先，我们需要改造一下前面的应用结构

建立一个如下的文件结构

- `(pages)`：这种加括号的目录属于[路由组][route-groups]，在自动组装url时会忽略。也就是要可以通过`/`来访问`(page)`中的页面。（请注意：这里的`(pages)`是自定义的，你可以写成`(web)`等， 并不影响）
- `@modal`：这种目录前加`@`符号的目录一般用于[并行路由][parallel-routes]。比如对于一个布局中同时加载几个块，但其中一个块非常耗时。为了让其它块快速先加载出来，这时就可以用到并行路由了。而在本节课中，并行路由被用于在布局中以”遮罩层+弹出框“的方式来打开文章编辑页面（同样的，这里的`modal`是自定义随意命名的，你也可以命名成`sidebar`等）
- `pasts/[item]`：这个目录结构用于[动态路由][dynamic-routes]。在`[item]`目录下的页面可以通过自动传入的`params.item`这个props获取在url中传入的`[item]`值。比如`/posts/1`，那么，`params.item`就是`1`。同时，还支持多参数，可选参数等，具体用法请看[官方文档][dynamic-routes]。（同样的，这里的`item`也是自定义随意命名的，你也可以命名成`slug`等）
- `src/app/layout.tsx`和`src/app/(pages)/layout.tsx`：使用两个布局文件的目的在于“拆分布局”。外部的布局用于包装基本的html元素，比如`<head>`、`<body>`等，内部的布局用于整个应用的页面布局。这样做的好处是，在应用组件变大时，许多页面会用到不同的布局。比如文章列表的博客页会有个侧边栏，而首页则不需要，但是首页有个`footer`等，这样做就方便灵活调整（当然，本篇课程的应用比较简单，用不到多个布局^v^）

```shell
./src/app
├── (pages)
│   ├── @modal # 并行路由的弹出框页面
│   │   ├── default.tsx
│   │   └── post-edit
│   │       └── [item]
│   ├── default.tsx
│   ├── global.css # 应用级别全局样式
│   ├── layout.module.css
│   ├── layout.tsx # 应用布局
│   ├── page.module.css
│   ├── page.tsx # 首页
│   └── posts
│       ├── [item]  # 文章展示页面
│       │   ├── page.module.css
│       │   └── page.tsx
│       └── create  # 文章创建页面
│           ├── form.tsx
│           ├── page.tsx
│           └── style.module.css
├── _components # 组件库
│   ├── collapsible # 表单可选字段折叠组件
│   ├── header # 布局顶栏组件
│   ├── home # 首页用到的特殊组件
│   ├── modal # 弹出框页面组件
│   ├── paginate
│   ├── post # 文章相关组件
│   ├── shadcn
│   └── theme
├── actions  # 数据操作
│   └── post.ts
├── favicon.ico
├── layout.tsx # 全局布局
└── styles # 全局样式
```

## 模拟数据

我们所接触到的大多数web应用其核心就是数据的存取和操作，而这些操作大多在数据库中操作。目前我们还没有接触到数据库（下一节开始即将学习数据库使用）。所以，我们暂时用json文件来存储数据。

在编写数据操作之前，先安装一下uuid生成库，用于生成数据的id

```bash
pnpm add uuid
pnpm add @types/uuid -D
```

#### 辅助函数

编写一些有用的随机生成函数（创建一个`src/libs/random.ts`文件，把以下代码复制进去），用于后续操作。它们的具体作用自行查看注释

:::success

提示：这些函数的具体实现不需要深入研究，只要知道其用途即可。因为在用到这类工具函数时，要不lodash已经包含了，如果没包含就让chatgpt帮我们编写一个即可

:::

```typescript
// src/libs/random.ts
/**
 * 获取小于N的随机整数
 * @param count
 */
export const getRandomMin = (count: number) => Math.floor(Math.random() * count);

/**
 * 获取一定范围内的随机整数
 * @param min
 * @param max
 */
export const getRandomInt = (min: number, max: number) =>
    Math.floor(Math.random() * (Math.floor(max) - Math.ceil(min) + 1)) + min;

/**
 * 生成只包含字母的固定长度的字符串
 * @param length
 */
export const getRandomCharString = (length: number) => {
    let result = '';
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
    const charactersLength = characters.length;
    for (let i = 0; i < length; i++) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
};

/**
 * 从列表中获取一个随机项
 * @param list
 */
export const getRandItemData = <T>(list: T[]) => {
    return list[getRandomMin(list.length)];
};

/**
 * 从列表中获取多个随机项组成一个新列表
 * @param list
 */
export const getRandListData = <T>(list: T[]) => {
    const result: T[] = [];
    for (let i = 0; i < getRandomMin(list.length); i++) {
        const random = getRandItemData<T>(list);
        const canPush = !result.find((item) => {
            if ('id' in (random as Record<string, any>)) {
                const check = random as Record<string, any>;
                const current = item as Record<string, any>;
                return current.id === check.id;
            }
            return item === random;
        });
        if (canPush) result.push(random);
    }
    return result;
};
```

#### 分页函数

因为现在没用到prisma或mikro这些orm，只是临时数据，所以如果需要对文章进行分页，就必须自己编写一个分页函数。

首先，我们创建一个`src/database`目录，专门用于存放数据库操作的一些代码。然后，添加一个`src/database/types.ts`，在里面定义分页函数所需的类型接口，如下

```typescript
// src/database/types.ts
/**
 * 分页原数据
 */
export interface PaginateMeta {
    /**
     * 当前页项目数量
     */
    itemCount: number;
    /**
     * 项目总数量
     */
    totalItems?: number;
    /**
     * 每页显示数量
     */
    perPage: number;
    /**
     * 总页数
     */
    totalPages?: number;
    /**
     * 当前页数
     */
    currentPage: number;
}

/**
 * 分页选项
 */
export interface PaginateOptions {
    /**
     * 当前页数
     */
    page?: number;
    /**
     * 每页显示数量
     */
    limit?: number;
}

/**
 * 分页返回数据
 */
export interface PaginateReturn<E extends Record<string, any>> {
    meta: PaginateMeta;
    items: E[];
}
```

创建`src/database/utils.ts`，并在其中编写分页函数

```typescript
// src/database/utils.ts
/**
 * 数据分页函数
 * @param data
 * @param options
 */
/**
 * 数据分页函数
 * @param data
 * @param options
 */
export const paginate = async <T extends Record<string, any>>(
    data: T[],
    options: PaginateOptions,
): Promise<PaginateReturn<T>> => {
    // 当设置每页数据量小于1时，则设置为每页一条数据
    const limit = isNil(options.limit) || options.limit < 1 ? 1 : options.limit;
    // 如果当前页小于1，则设置当前页为第一页
    const page = isNil(options.page) || options.page < 1 ? 1 : options.page;
    // 起始数据游标，如果页面是第一页则从第1条数据开始截取，如果大于第一页则从当前页的第一条数据开始截取
    const start = page > 1 ? (page - 1) * limit + 1 : 0;
    const items = data.slice(start, start + limit);
    // 页面数量
    const totalPages =
        data.length % limit === 0
            ? Math.floor(data.length / limit)
            : Math.floor(data.length / limit) + 1;
    // 计算最后一页的数据量
    const remainder = data.length % limit !== 0 ? data.length % limit : limit;
    // 根据最优一页的数据量得出当前页面的数据量
    const itemCount = page < totalPages ? limit : remainder;
    return {
        items,
        meta: {
            totalItems: data.length,
            itemCount,
            perPage: limit,
            totalPages,
            currentPage: page,
        },
    };
};
```

#### 假数据

手动编写数据是非常麻烦的一件事，所以我们使用[faker.js][fakerjs]来生成一些如文章标题、文章内容等假数据，以便可以直接看到页面效果

安装faker.js

```bash
pnpm add @faker-js/faker
```

封装一个假数据函数。假数据的首选语言设置成中文，其次英文（因为有些api没有中文数据）

```typescript
// src/database/utils.ts
import { base, zh_CN, en, Faker } from '@faker-js/faker';
//...
/**
 * 创建faker实例
 */
export const faker = new Faker({
    locale: [zh_CN, en, base],
});
```

添加文章的数据类型接口

```typescript
// src/database/types.ts
// ...
/**
 * 文章类型
 */
export interface IPost {
    /**
     * 文章ID
     */
    id: string;
    /**
     * 文章标题
     */
    title: string;
    /**
     * 文章内容
     */
    body: string;
    /**
     * 文章封面图
     */
    thumb: string;
    /**
     * 文章摘要
     */
    summary?: string;
}
```

下面我们来添加一些假数据，这些数据大多数使用fakerjs生成。通过判断`src/database/db.json`这个文件是否存在来创建数据。如果已经存在，那么不再重复创建。如果不存在，那么创建该文件，并且把生成的假数据放进去。

创建一个`src/database/generator.ts`文件，并写入一些代码

**概念解释**

- `'use server';`标识符是用于编写next.js的服务端渲染代码的。虽然，所有文件默认就是`use server`，但是类似这种只有纯后端操作代码的文件中最好还是显示的写上`use server`。这些next.js全栈开发（[server action][server-action]）最重要的功能。相对而言，与客户端有交互的组件则必须显示地加上`'use client';`
- `use client;`这种客户端组件并不是代表是前端渲染的，其实也是后端渲染直出页面的。只不过在后端出页面后，对于一些交互功能（比如按钮点击，`useEffect`等），前端会进行一一对比，然后进行水合。所以，可以调用`use server;`中的函数，且并不影响SEO
- 因为next.js的后端(node)部分是使用esm规则的，所以无法直接使用commonjs的`__dirname`，需要自己封装一个。如下使用`path.dirname(fileURLToPath(import.meta.url))`获取当前运行文件所属的目录路径。关于ESM和Commonjs的区别可以自行谷歌查询相关资料或者直接问GPT等AI模型

:::note

faker会生成一些莫名其妙的非英文词，可能是因为词库不够的原因。反正无论如何不必在意，这只是临时的假数据

:::

```typescript
// src/database/generator.ts
'use server';

import { getRandomInt } from '@/libs/random';
import fs, { existsSync, readFileSync, writeFileSync } from 'node:fs';
import path, { resolve } from 'node:path';
import { fileURLToPath } from 'node:url';
import { v4 } from 'uuid';

import type { IPost } from './types';

import { faker } from './utils';

// 获取当前文件的目录
const __dirname = path.dirname(fileURLToPath(import.meta.url));

/**
 * 初始数据，生成22篇文章
 */
const posts: IPost[] = [...Array.from({ length: 22 }).keys()].map(() => ({
    // 生成uuid
    id: v4(),
    // 随机封面图
    thumb: `/uploads/thumb/post-${getRandomInt(1, 8)}.png`,
    // 生成1到3个段落的标题
    title: faker.lorem.paragraph({ min: 1, max: 3 }),
    // 生成3-6个段落的内容并把每个段落用换行符换行
    body: faker.lorem.paragraphs(getRandomInt(3, 6), '\n'),
    // 有49%的机率会生成一段摘要
    summary: Math.random() < 0.5 ? faker.lorem.text() : undefined,
}));

/**
 * 检测数据库文件，如果不存在则创建并把初始数据写入
 */
const checkDbFile = async () => {
    const dbPath = resolve(__dirname, 'db.json');
    if (!existsSync(dbPath)) {
        const json = JSON.stringify(posts);
        writeFileSync(dbPath, json);
    }
};

/**
 * 读取数据库文件中的文章数据
 */
export const readDbFile = async (): Promise<IPost[]> => {
    // 先检测一下数据库文件，不存在则创建并写入初始数据
    await checkDbFile();
    const dbPath = resolve(__dirname, 'db.json');
    const data = readFileSync(dbPath, 'utf-8');
    return JSON.parse(data);
};

/**
 * 重写数据库文件
 * @param data
 */
export const resetDbFile = async (data: IPost[]) => {
    // 先检测一下数据库文件，不存在则创建并写入初始数据
    await checkDbFile();
    const dbPath = resolve(__dirname, 'db.json');
    const json = JSON.stringify(data);
    fs.writeFileSync(dbPath, json);
};
```

为了在每次启动应用时，把数据重置为初始数据，我们需要在`package.json`的`dev`命令前删除`src/database/db.json`这个文件

然后，修改`package.json`

```json
{
    "scripts": {
        "dev": "rimraf -rf .next src/database/db.json && next dev --turbopack"
        // ...
    }
}
```

并把这个文件从`eslint`配置中排除

```js
// eslint.config.mjs
// ...
export default antfu(
    {
        // ...
        ignores: [
            // ...
            'src/database/db.json',
        ],
    },

```

#### 数据操作

客户端在组件中要使用服务端操作的函数，必须在编写这些函数的文件顶部加上`use server;`标识符。如果函数实在定义客户端组件的`.tsx`文件中定义的，那么，就需要在这些函数的函数体中机上`use server;`标识符。例如

```tsx
export const queryPostPaginate = async (
    options?: PaginateOptions,
): Promise<PaginateReturn<IPost>> => {
    'use server;';
    const posts = await readDbFile();
    return paginate(posts, { page: 1, limit: 8, ...options });
};
```

文章数据操作其实就是读取和编辑json文件中的数据，其代码如下

```typescript
// src/app/actions/post.ts
'use server';
//...

/**
 * 查询分页文章列表信息
 * @param options
 */
export const queryPostPaginate = async (
    options?: PaginateOptions,
): Promise<PaginateReturn<IPost>> => {
    // 此处使用倒序,以便新增的文章可以排在最前面
    const posts = (await readDbFile()).reverse();
    return paginate(posts, { page: 1, limit: 8, ...options });
};

/**
 * 根据查询条件获取文章总页数
 * @param limit
 */
export const queryPostTotalPages = async (limit = 8): Promise<number> => {
    const data = await queryPostPaginate({ page: 1, limit });
    return data.meta.totalPages ?? 0;
};

/**
 * 根据ID查询文章信息
 * @param id
 */
export const queryPostItem = async (id: string): Promise<IPost | null> => {
    const posts = await readDbFile();
    const item = posts.find((post) => post.id === id);
    if (isNil(item)) throw new Error('post not exists!');
    return item;
};

/**
 * 根据ID查询文章信息
 * @param id
 */
export const queryPostItemById = async (id: string): Promise<IPost | null> => {
    const posts = await readDbFile();
    const item = posts.find((post) => post.id === id);
    if (isNil(item)) throw new Error('post not exists!');
    return item;
};

/**
 * 新增文章
 * @param data
 */
export const createPostItem = async (data: Omit<IPost, 'id'>): Promise<IPost> => {
    const posts = await readDbFile();
    const item: IPost = {
        ...data,
        id: v4(),
        thumb: `/uploads/thumb/post-${getRandomInt(1, 8)}.png`,
    };
    posts.push(item);
    await resetDbFile(posts);
    return item;
};

/**
 * 更新文章
 * @param id
 * @param data
 */
export const updatePostItem = async (
    id: string,
    data: Partial<Omit<IPost, 'id'>>,
): Promise<IPost | null> => {
    let posts = await readDbFile();
    const item = await queryPostItemById(id);
    if (isNil(item)) return null;
    const result = {
        ...(await queryPostItemById(id)),
        ...data,
    } as IPost;
    posts = posts.map((post) => (post.id === id ? result : post));
    await resetDbFile(posts);
    return result;
};

/**
 * 删除文章
 * @param id
 */
export const deletePostItem = async (id: string): Promise<IPost | null> => {
    let posts = await readDbFile();
    const item = await queryPostItemById(id);
    if (isNil(item)) return null;
    posts = posts.filter((post) => post.id !== id);
    await resetDbFile(posts);
    return item;
};
```

## 应用开发

现在我们开始正式编写应用。在编写页面前一定要仔细阅读[服务端渲染和客户端渲染的页面](https://nextjs.org/docs/app/building-your-application/rendering/composition-patterns)

:::info

再次提示：不加标识符的页面和组件默认就是服务端渲染（`use server;`）。而一些用到hooks的页面或组件需要加上`use client;`使其变成客户端渲染页面

:::

### 前置工作

在开始编码前先需要下载[源码](https://git.3rcd.com/classroom/ts-fullstack/src/branch/main/chapter5/public/uploads/thumb)中的文章封面图片[public/uploads/thumb](https://git.3rcd.com/classroom/ts-fullstack/src/branch/main/basic/chapter6/public/uploads/thumb)目录复制到应用中对应的目录， 因为文章的封面图在正常情况下是有作者上传的，所以需要放到云存储或简单地放到web可访问目录，比如`public`中

### 应用首页

首页实现以下功能

- 显示文章创建按钮
- 当前页文章数量大于0时，显示分页组件
- 显示分页文章列表。当前页文章数量小于0或者大于总页数时，跳转到第一页
- 当页面在第一页时，在URL中隐藏`?page=1`的查询参数
- 文章标题只显示一行文字，且溢出部分用省略号代替
- 在文章列表中拥有编辑、删除按钮

#### 工具栏组件

编写一个工具栏组件，用于添加创建文章按钮以及访问文章详情后出现一个返回前一页的按钮

编写返回按钮

:::warning

注意：这是一个客户端组件（可以看到顶部的`'use client'`）。后续如无特殊情况，不再说明！

:::

:::warning

所有组件和页面中请确保`useRouter`是从`next/navigation`中导入的，而不是`next/router`。后续如无特殊情况，不再说明！

:::

```tsx
// src/app/_components/home/back-button.tsx
'use client';

import { useRouter } from 'next/navigation';
// ...
import { Undo2 } from 'lucide-react';

export const BackButton: FC = () => {
    const router = useRouter();
    const [historyLength, setHistoryLength] = useState(0);

    useEffect(() => {
        if (typeof window !== 'undefined') {
            setHistoryLength(window.history.length);
        }
    }, []);
    const goBack: MouseEventHandler<HTMLButtonElement> = useCallback(
        (e) => {
            e.preventDefault();
            if (historyLength > 1) router.back();
        },
        [historyLength],
    );

    return (
        <Button
            variant="outline"
            className={cn('tw-rounded-sm', {
                'tw-pointer-events-none tw-opacity-50': historyLength <= 1,
            })}
            disabled={historyLength <= 1}
            aria-disabled={historyLength <= 1}
            onClick={goBack}
        >
            <Undo2 />
            返回
        </Button>
    );
};
```

文章创建文件按钮

:::success因为用到`useSearchParams`这个延迟获取的hooks，所以必须使用`<Suspense>`组件包装 :::

```tsx
// src/app/_components/post/create-button.tsx
'use client';

// ...
import { IoMdAdd } from 'react-icons/io';

export const Button: FC = () => {
    const searchParams = useSearchParams();
    const getUrlQuery = useMemo(() => {
        const query = new URLSearchParams(searchParams.toString()).toString();
        // 保留当前分页的url查询，不至于在打开创建文章后，导致首页的文章列表重置分页
        return isNil(query) || query.length < 1 ? '' : `?${query}`;
    }, [searchParams]);
    return (
        <CNButton asChild className="tw-ml-auto tw-justify-end tw-rounded-sm" variant="outline">
            <Link href={`/posts/create${getUrlQuery}`}>
                <Plus />
                创建
            </Link>
        </CNButton>
    );
};

export const PostCreateButton: FC = () => (
    <Suspense>
        <Button />
    </Suspense>
);
```

编写工具栏组件

```tsx
// src/app/_components/home/tools.tsx
'use client';
// ...
import $styles from './tools.module.css';

export const Tools: FC<{ back?: boolean }> = ({ back }) => {
    return (
        <div className={$styles.tools}>
            {back && <BackButton />}
            <PostCreateButton />
        </div>
    );
};
```

样式

```css
/* src/app/_components/home/tools.module.css */
.tools {
    @apply tw-flex tw-justify-between tw-my-5 tw-mx-3 tw-w-full tw-max-h-12;
}
```

#### 文章列表

修改现在的首页`src/app/(pages)/page.tsx`， 显示分页的文章列表

其中`searchParams`这个参数是next.js自带的，用法参考[官方文档](https://nextjs.org/docs/app/api-reference/file-conventions/page#searchparams-optional)。用于在服务端页面或组件中获取url的查询参数，作用与上述客户端组件中的`useSearchParams`相同，但不能在布局页面中使用。目前在首页中的作用就是用于获取`?page=1&&limit=8`这种URL中的查询参数用于分页

另外，请不要忘记导入上面编写的工具栏组件

```tsx
// src/app/(pages)/page.tsx
// ...
import { Calendar } from 'lucide-react';

import $styles from './page.module.css';

const HomePage: FC<{ searchParams: Promise<IPaginateQueryProps> }> = async ({ searchParams }) => {
    const { page: currentPage, limit = 8 } = await searchParams;
    // 当没有传入当前页或当前页小于1时，设置为第1页
    const page = isNil(currentPage) || Number(currentPage) < 1 ? 1 : Number(currentPage);
    const { items } = await queryPostPaginate({ page: Number(page), limit });

    return (
        <div className="tw-page-container">
            <Tools />
            <div className={$styles.list}>
                {items.map((item) => (
                    <div
                        className={$styles.item}
                        // 传入css变量的封面图用于鼠标移动到此处后会出现不同颜色的光晕效果
                        style={{ '--bg-img': `url(${item.thumb})` } as any}
                        key={item.id}
                    >
                        <Link className={$styles.thumb} href={`/posts/${item.id}`}>
                            <Image
                                src={item.thumb}
                                alt={item.title}
                                fill
                                priority
                                sizes="100%"
                                unoptimized
                            />
                        </Link>
                        <div className={$styles.content}>
                            <div className={$styles.title}>
                                <Link href={`/posts/${item.id}`}>
                                    <h2 className="tw-ellips tw-animate-decoration tw-animate-decoration-lg">
                                        {item.title}
                                    </h2>
                                </Link>
                            </div>
                            <div className={$styles.summary}>
                                {isNil(item.summary) ? item.body.substring(0, 99) : item.summary}
                            </div>
                            <div className={$styles.footer}>
                                <div className={$styles.meta}>
                                    <span>
                                        <Calendar />
                                    </span>
                                    <time className="tw-ellips">2024年8月10日</time>
                                </div>
                                {/* 文章操作按钮 */}
                            </div>
                        </div>
                    </div>
                ))}
            </div>
            {/* 分页组件 */}
        </div>
    );
};

export default HomePage;
```

然后复制样式代码[src/app/(pages)/page.module.css](https://git.3rcd.com/classroom/ts-fullstack/src/branch/main/chapter5/src/app/%28pages%29/page.module.css)到应用中

有趣的是，我们加了一个光晕效果。根据不同的文章封面图，产生不同颜色的`shadow`扩散，可以研究一下样式文件中以下部分的代码

```css
/* src/app/(pages)/page.module.css */
.list {
    @apply tw-w-full;

    & .item {
        @apply tw-rounded-md tw-mb-8 tw-flex tw-flex-col
        tw-duration-300 tw-backdrop-blur-md
        tw-drop-shadow-[5px_5px_5px_rgba(0,0,0,0.35)];

        &:last-child {
            @apply tw-mb-0;
        }

        &:hover {
            &::before {
                @apply tw-opacity-100;
            }

            & > .content {
                @apply tw-bg-white/90 dark:tw-bg-black/80;
            }
        }

        &::before {
            content: '';

            @apply tw-opacity-0 tw-rounded-md  tw-overflow-hidden tw-duration-300
            tw-absolute tw-top-0 tw-left-0 tw-w-full tw-h-full tw-bg-[image:var(--bg-img)]
            tw-z-[-1] tw-bg-center tw-bg-cover;
            filter: blur(30px) opacity(70%) brightness(120%);
        }

        /* ... */
}
```

启动应用，可以看到效果如图

![](https://cn-nb1.rains3.com/3rcd/media/1735754714971.gif)

#### 分页组件

编写一个对文章列表进行分页

首先，通过shadcn/ui的分页组件来编写一个通用的简单分页组件

```bash
pnpm addsc pagination # 安装shadcn/ui 分页组件
```

修改shadcn分页组件的`PaginationLink`，使其拥有以下功能

- 添加按钮禁用功能
- 自定义分页按钮文字
- 使用next.js的`Link`标签替换默认的`a`标签
- 对禁用的按钮添加半透明效果

修改部分的代码如下

:::warning建议直接复制课程[源码](https://git.3rcd.com/classroom/ts-fullstack/src/branch/main/chapter5/src/app/_components/shadcn/ui/pagination.tsx)中的这部分代码，以免出错 :::

```tsx
// src/app/_components/shadcn/ui/pagination.tsx
// ...
type PaginationLinkProps = {
    isActive?: boolean;
    disabled?: boolean;
    text?: string;
} & Pick<ButtonProps, 'size'> &
    React.ComponentProps<'a'>;

const PaginationLink = ({ className, isActive, size = 'icon', ...props }: PaginationLinkProps) => (
    <Link
        aria-current={isActive ? 'page' : undefined}
        aria-disabled={props.disabled}
        className={cn(
            buttonVariants({
                variant: isActive ? 'outline' : 'ghost',
                size,
            }),
            cn({ 'tw-pointer-events-none tw-opacity-50': props.disabled }),
            className,
        )}
        href={isNil(props.href) ? ':' : props.href}
        {...props}
    />
);

const PaginationPrevious = ({
    className,
    text,
    ...props
}: React.ComponentProps<typeof PaginationLink>) => (
    <PaginationLink {/* 属性 */}>
        <ChevronLeft className="tw-h-4 tw-w-4" />
        <span>{text ?? 'Previous'}</span>
    </PaginationLink>
);

const PaginationNext = ({
    className,
    text,
    ...props
}: React.ComponentProps<typeof PaginationLink>) => (
    <PaginationLink {/* 属性 */}>
        <span>{text ?? 'Next'}</span>
        <ChevronRight className="tw-h-4 tw-w-4" />
    </PaginationLink>
);

const PaginationEllipsis = ({
    className,
    text,
    ...props
}: React.ComponentProps<'span'> & { text?: string }) => (
    <span {/* 属性 */}>
        <MoreHorizontal className="tw-h-4 tw-w-4" />
        <span className="tw-sr-only">{text ?? 'More pages'}</span>
    </span>
);

```

下面编写一个通用的简单数据分页组件

该组件通过“上一页”和“下一页”按钮进行分页。

实现的功能为

- 当页面为第一页时，没有`?page=1`的url后缀，因为第一页时默认页
- 当页面不是第一页时，会有`?page=2`的url后缀来确定当前访问页面
- 在当前页小于`1`或者是大于总页数时，分页会禁用“上一页”和“下一页”按钮
- `getPageUrl`函数的作用在于替换掉url中的查询参数。比如，如果我们后续要加上排序查询，`?sort=createdAt`，又或者在添加页面数据显示量参数`?limit=10`时。那么，如果直接把url改成`/?page=2`会丢掉排序查询的参数。所以使用`params.set`来设置页面查询参数
- `useEffect`中的代码用于在当前页数量小于等于`1`，比如`page?=-1`时，强制删除页面查询参数

整体代码如下

:::info

由于使用了`useSearchParams`，所以同样要包装在`<Suspense>`组件中

:::

```tsx
// src/app/_components/paginate/simple.tsx
'use client';
// ...

export const Pagination: FC<{ totalPages: number; currentPage: number }> = ({
    totalPages,
    currentPage,
}) => {
    const searchParams = useSearchParams();
    const router = useRouter();
    const pathname = usePathname();
    const getPageUrl = useCallback(
        (value: number) => {
            const params = new URLSearchParams(searchParams);
            value <= 1 ? params.delete('page') : params.set('page', value.toString());

            return pathname + (params.toString() ? `?${params.toString()}` : '');
        },
        [searchParams],
    );
    useEffect(() => {
        // 在当前页面小于等于1时，删除URL中的页面查询参数
        const params = new URLSearchParams(searchParams);
        if (currentPage <= 1) params.delete('page');
        router.replace(pathname + (params.toString() ? `?${params.toString()}` : ''));
    }, [currentPage]);
    return totalPages > 1 ? (
        <CNPagination className="tw-justify-start">
            <PaginationContent className="tw-w-full tw-justify-between">
                <PaginationItem>
                    <PaginationPrevious
                        className={clsx(
                            'tw-rounded-sm',
                            currentPage <= 1
                                ? 'tw-bg-slate-50/70 tw-shadow-gray-50'
                                : ' tw-bg-white/90 hover:tw-shadow-nylg hover:tw-shadow-white',
                        )}
                        href={getPageUrl(currentPage - 1)}
                        disabled={currentPage <= 1}
                        aria-label="访问上一页"
                        text="上一页"
                    />
                </PaginationItem>

                <PaginationItem>
                    <PaginationNext
                        className={clsx(
                            'tw-rounded-sm',
                            currentPage >= totalPages
                                ? 'tw-bg-slate-50/70 tw-shadow-gray-50  dark:tw-bg-slate-800/70 dark:tw-shadow-gray-800'
                                : ' tw-bg-white/90 hover:tw-shadow-nylg hover:tw-shadow-white dark:tw-bg-black/90 dark:hover:tw-shadow-black',
                        )}
                        href={getPageUrl(currentPage + 1)}
                        disabled={currentPage >= totalPages}
                        aria-label="访问下一页"
                        text="下一页"
                    />
                </PaginationItem>
            </PaginationContent>
        </CNPagination>
    ) : null;
};
export const SimplePaginate: FC<{ totalPages: number; currentPage: number }> = ({
    totalPages,
    currentPage,
}) => (
    <Suspense>
        <Pagination totalPages={totalPages} currentPage={currentPage} />
    </Suspense>
);
```

接下来，编写文章分页组件

先定义一个通用的数据列表分页查询条件接口

- `page`: 用于定义当前页，默认为第`1`页（在组件中设置默认值）
- `limit`: 用于定义每页的数据量，在组件中设置默认值

```tsx
// src/app/_components/paginate/types.ts
/**
 * 数据分页查询条件接口
 */
export type IPaginateQueryProps<T extends Record<string, any> = Record<never, never>> = {
    page?: number;
    limit?: number;
} & T;
```

定义文章列表分页组件

```tsx
// src/app/_components/post/paginate.tsx
// ...
export const PostListPaginate: FC<{ limit: number; page: number }> = async ({ limit, page }) => {
    const totalPages = await queryPostTotalPages(limit);
    return (
        <div className="tw-mb-5 tw-w-full tw-flex-none">
            <SimplePaginate totalPages={totalPages} currentPage={page} />
        </div>
    );
};
```

在首页（文章列表页）中调用分页组件

:::info

再次提醒：`searchParams`这个props在服务器组件中可以自动获取，而在客户端组件中也可以通过`useSearchParams`这个hooks获取

:::

- `IPaginateQueryProps`：条件url参数的分页数据列表查询接口
- `Number(currentPage)`: 用于转换url中传入的当前页的字符串类型为数字类型
- `limit`用于设置每页数据量，可通过`?page=2&&limit=10`这样的url改变
- 因为现在我们还没有学习到next.js的错误页面定义，所以在当前页超过总页数时跳转到第一页

```tsx
// src/app/(pages)/page.tsx
// ...
import { PostListPaginate } from '../_components/post/paginate';

const HomePage: FC<{ searchParams: IPaginateQueryProps }> = async ({ searchParams }) => {
    {
        /* ... */
    }
    const { items, meta } = await queryPostPaginate({ page: Number(page), limit });

    if (meta.totalPages && meta.totalPages > 0 && page > meta.totalPages) {
        return redirect('/');
    }
    return (
        <div className="tw-page-container">
            <Tools />
            <div className={$styles.list}>{/* ... */}</div>
            {meta.totalPages! > 1 && <PostListPaginate limit={8} page={page} />}
        </div>
    );
};
export default HomePage;
```

效果如下 ![](https://cn-nb1.rains3.com/3rcd/media/1735755532915.gif)

### 文章操作

现在，我们编写一下文章的CRUD（创建、读取、更新、删除）页面

#### 删除文章

最简单的就是文章擅长功能，所以我们先写这个

删除是一个弹出框，然后确认的模式，所以先安装一下shadcn的弹出框组件

```bash
pnpm addsc alert-dialog
```

编写删除组件。该组件是一个弹出对话框，注意以下两点

- 在删除文章后我们需要使用`router.refresh()`刷新一下页面才能看到效果。但是这并不是类似`window.location.reload()`一样的刷新整个浏览器，而只是刷新next.js页面
- `AlertDialogContent`设置`onEscapeKeyDown={(event) => event.preventDefault()}`的目的在于，防止按`esc`键关闭弹出框

```tsx
// src/app/_components/post/delete.tsx
'use client';
// ...

export const PostDelete: FC<{ id: string }> = ({ id }) => {
    const router = useRouter();
    const [open, setOpen] = useState(false);
    const [pedding, setPedding] = useState(false);

    const changeOpen = useCallback((value: boolean) => {
        setOpen(value);
    }, []);

    const close: MouseEventHandler<HTMLButtonElement> = useCallback((e) => {
        e.preventDefault();
        if (!pedding) setOpen(false);
    }, []);

    const deleteItem: MouseEventHandler<HTMLButtonElement> = useCallback(
        async (e) => {
            try {
                e.preventDefault();
                setPedding(true);
                await deletePostItem(id);
                setPedding(false);
                setOpen(false);
            } catch (error) {
                console.error(error);
            }

            // 删除文章后刷新页面
            router.refresh();
        },
        [id],
    );
    return (
        <AlertDialog open={open} onOpenChange={changeOpen}>
            <AlertDialogTrigger asChild>
                <Button variant="outline">
                    <Trash2 />
                    删除
                </Button>
            </AlertDialogTrigger>
            <AlertDialogContent onEscapeKeyDown={(event) => event.preventDefault()}>
                <AlertDialogHeader>
                    <AlertDialogTitle>是否确认删除该文章？</AlertDialogTitle>
                    <AlertDialogDescription>
                        当前不支持软删除，删除文章后将无法恢复
                    </AlertDialogDescription>
                </AlertDialogHeader>
                <AlertDialogFooter>
                    <AlertDialogCancel disabled={pedding} onClick={close}>
                        取消
                    </AlertDialogCancel>
                    <AlertDialogAction onClick={deleteItem} disabled={pedding}>
                        {pedding ? '删除中' : '确认'}
                    </AlertDialogAction>
                </AlertDialogFooter>
            </AlertDialogContent>
        </AlertDialog>
    );
};
```

编写一个`PostActionButtons`组件，把以上组件导入其中。再把这个组件放入文章列表页，如下

```tsx
// src/app/(pages)/page.tsx
'use client';
// ...

import type { FC } from 'react';

import { PostDelete } from './delete';

export const PostActionButtons: FC<{ id: string }> = ({ id }) => {
    return (
        <div className="tw-flex tw-items-center [&>time]:tw-ml-2">
            <PostDelete id={id} />
        </div>
    );
};

// src/app/(pages)/page.tsx
// ...
<div className={$styles.footer}>
    <div className={$styles.meta}>
        <span>
            <Calendar />
        </span>
        <time className="tw-ellips">2024年8月10日</time>
    </div>
    <PostActionButtons id={item.id} />
</div>;
```

![](https://cn-nb1.rains3.com/3rcd/media/1735755953730.gif)

#### 并行路由

这个应用需要制作一个效果。就是在编辑文章是一个弹出框表单页面，而且在刷新浏览器时，同样保持弹出框状态。这需要用到[next.js的并行路由](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes)

安装[micromatch](https://github.com/micromatch/micromatch)用于模糊匹配glob路径

```bash
pnpm add micromatch
pnpm add @types/micromatch -D
```

我们先编写一个通用的弹出框

安装shadcn的dialog组件

```bash
pnpm addsc dialog
```

弹出框页面使用并行路由处理，需要实现以下几点特性

:::note

为了更方便地研究代码，下面代码中分别使用提示语**实现上述特性x**来逐步讲述如何实现这些特性

:::

1. 所有的并行路由必须放在一个`@`开的头的目录或其子孙目录下（例如`src/app/(pages)/@modal/post-edit/[item]/page.tsx`），这样才能使用与`@modal`同级别的布局文件识别到，并在props中拿到这个去除`@`开头的参数（例如`modal`）。这个参数就代表当前激活的并行路由页面。
2. 当前访问的路由路径为使用弹出框组件包装的并行路由页面时，这个并行路由处于激活状态。比如，访问`/post/post-edit/{id}`，那么，`src/app/(pages)/@modal/post-edit/[item]/page.tsx`这个弹出框页面将被打开。而同一个级别下的其它弹出框页面这返回`null`。要实现这个特性，只要在所有弹出框页面的上级或同级目录下添加一个`default.tsx`，让它返回`null`即可
3. 事实上`children`也可以算作一个固定写法的并行路由。所以，`src/app/(pages)/@children/page.tsx`和`src/app/(pages)/page.tsx`的作用是一样的。所以，你同样可以为`@children`这个默认的并行路由加一个`default.tsx`垫片。可以写在`src/app/(pages)/@children`中，也可以写在`src/app/(pages)`中
4. 弹出框是通过匹配路由来直接显示节点到`body`中，而不是通过打开或关闭来控制的，所以`open`永远设置成`true`。
5. 因为布局只能判断与其同级别的并行路由的激活状态（例如`src/app/(pages)/layout.tsx`只能判断`src/app/(pages)/@modal`中的并行路由页面的激活状态）。所以，当访问`/`时，所有并行路由都没有激活，都返回`null`（即`default.tsx`）。所以，当使用弹出框来创建文章时，如果我们的需求是创建文章后跳转到文章详情页`src/app/(pages)/posts/[item]/page.tsx`。这时，会出现在详情页上层有个显示`/post-edit`这个弹出框页面。为此，需要在弹出框的并行路由页面中使用glob的`match`来模糊匹配到当前路径（我们自己添加的规则）,如果当前的URL对应的路由不是某个并行路由页面，则使这个页面返回`null`。例如，路由`/post-edit/{id}`页面位于`src/app/(pages)/@modal/post-edit/[item]/page.tsx`。那么，在这个`page.tsx`中，用`PageModal`包装时，需要传入`['/post-edit/*']`，然后使用`glob.isMatch`对比当前路由是否匹配，不匹配则返回`null`
6. 对于并行路由，弹出框使用永久打开状态的，并不是通过`open`来控制。关闭弹出框其实是在点"x"按钮后，返回上一页。因为路由改变了，所以，一、弹出框页面就不处于激活状态了，就返回`default.tsx`的`null`了。二、`glob.isMatch`匹配的当前路由和弹出框路由也不匹配了，所以页面本身也返回`null`了。这样，就自然关闭了

编写一个`modal`弹出框组件

定义以下类型

```typescript
// src/app/_components/modal/types.ts
import { PropsWithChildren } from 'react';
/**
 * 页面弹出框的参数类型
 */
export type PageModalProps = PropsWithChildren<{
    /**
     * 弹出框标题
     */
    title: string;
    /**
     * 匹配的路由（只有当当前路由包含在此选项内时，才有可能显示弹出框）
     */
    match: string[];
    /**
     * 自定义的DialogContent样式类
     */
    className?: string;
}>;
```

编写弹出框组件，**实现上述特效5和6**。注意以下两点

- `Dialog`外面包一层`div`的原因是因为弹出框是`fixed`，所以在直接刷新弹出框页面时，会出现自动滚动警告。具体原因不用理会，务必加上就是

- `onEscapeKeyDown`和`onInteractOutside`设置为`(event) => event.preventDefault()`的目的在于，打开弹出框后，只能点`x`按钮关闭。而不能点遮罩层或者按`esc`键关闭

```tsx
// src/app/_components/modal/page-modal.tsx
'use client';
// ...
import $styles from './page-modal.module.css';

export const PageModal: FC<PageModalProps> = ({ title, match, className, children }) => {
    const pathname = usePathname();
    const router = useRouter();
    const [show, setShow] = useState(false);
    useEffect(() => {
        setShow(
            glob.isMatch(
                trim(pathname, '/'),
                match.map((m) => trim(m, '/')),
            ),
        );
    }, [pathname, ...match]);
    const close = useCallback(() => router.back(), []);
    return show ? (
        <Dialog open defaultOpen onOpenChange={close}>
            <DialogContent
                className={clsx('sm:tw-max-w-[80%]', className)}
                onEscapeKeyDown={(event) => event.preventDefault()}
                onInteractOutside={(event) => event.preventDefault()}
            >
                <DialogHeader>
                    <DialogTitle>{title}</DialogTitle>
                    <DialogDescription />
                </DialogHeader>
                <div className={$styles.modalContent}>{children}</div>
            </DialogContent>
        </Dialog>
    ) : null;
};
```

样式如下

```css
/* src/app/_components/modal/page-modal.module.css */
.modalWrapper {
    @apply tw-w-full tw-h-full tw-flex-auto;
}

.modalContent {
    @apply tw-overflow-y-auto tw-max-h-[80vh] tw-w-full tw-px-3;
}
```

编写并行路由来操作弹出框页面

在`src/app/@modal`目录中添加一个文章编辑页面弹出框，以**实现上述特性1**

```tsx
// src/app/(pages)/@modal/post-create/page.tsx
// ...

import { notFound } from 'next/navigation';

const PostEditPage: FC<{ params: Promise<{ item: string }> }> = async ({ params }) => {
    const { item } = await params;
    if (isNil(item)) return notFound();

    return (
        <PageModal
            title="编辑文章"
            match={['/post-edit/*']}
            className="tw-min-w-full lg:tw-min-w-[60%]"
        >
            编辑
        </PageModal>
    );
};

export default PostEditPage;
```

然后，在页面布局中加入这个弹出框页面的并行路由，即`modal`。这样就**实现上述特性4**了

```tsx
// src/app/(pages)/layout.tsx
// ...
const AppLayout: FC<PropsWithChildren<{ modal: ReactNode }>> = ({ children, modal }) => (
    <Theme>
        <div className={$styles.layout}>
            <Header />
            {children}
        </div>
        {modal}
    </Theme>
);
export default AppLayout;
```

然后编写一个编辑按钮，并把它放入`PostActionButtons`组件中

:::info

在点开按钮并打开编辑模态页面时，把浏览器地址栏的查询参数也放进去，这样可以方便我们在编辑完文章后跳转时还会附带上这些查询参数。比如当前页面等

:::

```tsx
// src/app/_components/post/edit-button.tsx
'use client';
// ...
const Button: FC<{ id: string }> = ({ id }) => {
    const searchParams = useSearchParams();
    const getUrlQuery = useMemo(() => {
        const query = new URLSearchParams(searchParams.toString()).toString();
        return isNil(query) || query.length < 1 ? '' : `?${query}`;
    }, [searchParams]);
    return (
        <CNButton asChild className="tw-mr-3">
            <Link href={`/post-edit/${id}${getUrlQuery}`}>
                <UserPen />
                编辑
            </Link>
        </CNButton>
    );
};

export const PostEditButton: FC<{ id: string }> = ({ id }) => (
    <Suspense>
        <Button id={id} />
    </Suspense>
);

// src/app/_components/post/list.tsx
// ...
export const PostActionButtons: FC<{ id: string }> = ({ id }) => {
    return (
        <div className="tw-flex tw-items-center [&>time]:tw-ml-2">
            <PostEditButton id={id} />
            <PostDelete id={id} />
        </div>
    );
};
```

这时，查看页面会发现变成404页面了。这就是我们需要**实现上述特性2**的原因

这是因为，在访问`/`的时候，`{modal}`无法匹配到`/post/post-edit/{id}`等任何一个并行路由，所有并行路由都没有被激活。但`{modal}`已经放入布局，而`{modal}`无法匹配到任何路由，所以报404。就像前面说的，这是你需要在`src/app/(pages)/@modal/post-edit/[item]`目录或者上级的`src/app/(pages)/@modal`目录下添加一个当该并行路由没有被激活时的默认页面`default.tsx`。`default.tsx`用于当没有任何并行路由被激活时被渲染，我们让它返回`null`就可以了。这样`{modal}`匹配到的就是`null`而不是找不到页面了！

```tsx
// src/app/(pages)/@modal/default.tsx
import { FC } from 'react';

const DefaultModalPage: FC = () => null;
export default DefaultModalPage;
```

而当你访问`/post/post-edit/{id}`时，`/`的`{children}`没有被激活了。事实上`{children}`是一个默认的并行路由。也就是你也可以把首页`src/app/page.tsx`移动到`src/app/@children/page.tsx`里面去的。所以，这时，我们需要添加一个`{children}`的`default.tsx`。这个`default.tsx`导出`src/app/page.tsx`这个页面即可。因为，他需要的效果与首页一模一样。这就**实现了上述特性3**

```tsx
// src/app/(pages)/default.tsx
import { default as DefaultHomePage } from './page';

export default DefaultHomePage;
```

现在，一切看起来很正常了

![](https://cn-nb1.rains3.com/3rcd/media/1735760656408.gif)

#### 动态路由

我们需要访问或编辑（更新）某篇文章时，一般通过`/posts/{id}`或`/post-edit/{id}`这样的URL去访问页面的。在next.js怎么去实现呢？通过上面部分的讲解，我们可以得到答案，那就是通过[动态路由](https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes)。可以通过定义`src/app/post/[item]/page.tsx`这样的方法来定义我们的页面。然后在props中获取`item`的值即可。其中`[item]`是可以自定义的，可以是`[id]`等等。只要与props中获取的参数对应即可

:::info

参数可以是可选的（通过`[[item]]`这样的目录格式定义）也可以是个数组（通过`[...item]`这样的目录格式定义）。更多详情请参考[官方文档](https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes)

:::

:::success

只有服务端渲染的页面才可以使用`async`

:::

编写一个演示性的文章详情页

```tsx
// src/app/(pages)/posts/[item]/page.tsx
// 文章显示页面
// ...
import $styles from './page.module.css';

const PostItemPage: FC<{ params: Promise<{ item: string }> }> = async ({ params }) => {
    const { item } = await params;
    const post = await queryPostItem(item);
    if (isNil(post)) return notFound();
    return (
        <div className="tw-page-container">
            <Tools back />
            <div className={$styles.item}>
                <div className={$styles.item}>id: {params.item}</div>
            </div>
        </div>
    );
};
export default PostItemPage;
```

样式

```css
/* src/app/(pages)/posts/[item]/page.module.css */
.item {
    @apply tw-bg-white/80 tw-flex-auto tw-w-full tw-drop-shadow-lg tw-rounded-md tw-flex tw-flex-col;
}
```

点击一篇文章的标题，就会跳转到该文章的详情页并显示id

#### 创建和编辑页

有了上述知识，接下来我们开始正式编写所需的页面。

先编写文章操作表单。为了方便，创建文章和更新文章的表单是同一个表单组件

:::success

本节课没有涉及到数据验证，所以直接简单地保存数据。后续课程再学习用zod进行数据验证

:::

安装所需依赖

```bash
pnpm add react-hook-form
pnpm add utility-types -D
```

安装所需的shadcn组件

```bash
pnpm addsc form input textarea
```

定义以下类型

```typescript
// src/app/_components/post/types.ts
// ...
/**
 * 文章操作表单组件创建文章操作的参数
 */
export interface PostCreateFormProps {
    type: 'create';
    /**
     * 在文章正在创建时执行一些动画
     * @param value
     */
    setPedding?: (value: boolean) => void;
}

/**
 * 文章操作表单组件更新文章操作的参数
 */
export interface PostUpdateFormProps {
    type: 'update';
    // 原来的文章数据，用于作为默认值数据与表单中编辑后的新数据合并，然后更新
    item: IPost;
}

/**
 * 文章操作表单在创建文章时的submit(提交表单)函数的参数
 */
export type PostCreateData = Omit<IPost, 'id'>;

/**
 * 文章操作表单在更新文章时的submit(提交表单)函数的参数
 */
export type PostUpdateData = Partial<Omit<IPost, 'id'>> & { id: string };
/**
 * 文章创建/编辑表单的参数类型
 */
export type PostActionFormProps = PostCreateFormProps | PostUpdateFormProps;
/**
 * 文章操作表单的submit(提交表单以创建或更新文章)函数参数
 */
export type PostFormData = PostCreateData | PostUpdateData;

/**
 * 文章创建表单的Ref,配合useImperativeHandle可以在表单外部页面调用表单提交函数
 */
export interface PostCreateFormRef {
    create?: (e?: BaseSyntheticEvent) => Promise<void>;
}
```

编写两个hooks

- `usePostActionForm`：使用[react-form-hooks][react-form-hooks]的`useForm`钩子，生成一个表单状态，然后结合shadcn的表单组件生成一个react表单
- `usePostFormSubmitHandler`：生成表单提交处理器函数，用于创建和更新文章数据

注意点：

- 表单中的数据不能为`null`或`undefined`，所以对于可选数据（比如`summary`），需要使用空字符串代替`null`或`undefined`。类型需要使用`DeepNonNullable`包装一下
- `useForm`这个hooks shadcn使用默认推荐使用[react-hook-form][react-hook-form]来构建表单，而`useForm`就是该库的核心hooks。通过它可以快速地操作和拿到表单值。通过`useForm`为创建或更新表单增加了一些默认值，使得操作更流畅。`defaultValues`中定义的是默认值，会和表单提交的数据进行合并。因为我们目前没有进行数据验证这一步，所以添加默认值显然防止了一些不友好的问题产生
- 在获取表单数据后，提交时，我们在`usePostFormSubmitHandler`中遍历数据，删除所有空字符串的字段（比如，没有写`summary`）。那样，这个字段的值就会是`undefined`，这会在表单结合数据库操作数据时很有用
- 数据在创建或更新后，跳转到文章详情页面。推荐使用`replace`而不是`push`进行跳转！

```typescript
// src/app/_components/post/hooks.ts
'use client';
// ...
import type { DeepNonNullable } from 'utility-types';
import { useForm } from 'react-hook-form';

import type { PostCreateData, PostFormData, PostUpdateData } from './types';

/**
 * 生成react-form-hooks表单的状态
 * 目前仅传入默认数据参数到useForm,后续我们会增加一些zod验证等其它参数
 * @param params
 */
export const usePostActionForm = (params: { type: 'create' } | { type: 'update'; item: IPost }) => {
    // 定义默认数据
    const defaultValues = useMemo(() => {
        if (params.type === 'create') {
            return {
                title: '文章标题',
                body: '文章内容',
                summary: '',
            } as DeepNonNullable<PostCreateData>;
        }

        return {
            title: params.item.title,
            body: params.item.body,
            summary: isNil(params.item.summary) ? '' : params.item.summary,
        } as DeepNonNullable<PostUpdateData>;
    }, [params.type]);
    return useForm<DeepNonNullable<PostFormData>>({
        defaultValues,
    });
};
/**
 * 生成表单submit(提交)函数用于操作数据的钩子
 * @param params
 */
export const usePostFormSubmitHandler = (
    params: { type: 'create' } | { type: 'update'; id: string },
) => {
    const router = useRouter();
    return useCallback(
        async (data: PostFormData) => {
            let post: IPost | null;
            for (const key of Object.keys(data) as Array<keyof PostFormData>) {
                const value = data[key];

                if (typeof value === 'string' && !trim(value, '')) {
                    delete data[key];
                }
            }
            try {
                // 更新文章
                if (params.type === 'update') {
                    post = await updatePostItem(params.id, data as PostUpdateData);
                }
                // 创建文章
                else {
                    post = await createPostItem(data as PostCreateData);
                }
                // 创建或更新文章后跳转到文章详情页
                // 注意,这里不要用push,防止在详情页后退后返回到创建或编辑页面的弹出框
                if (!isNil(post)) router.replace(`/posts/${post.id}`);
            } catch (error) {
                console.log('error', error);
            }
        },
        [{ ...params }],
    );
};
```

编写一个折叠组件。对于一些可选字段，使用[details标签](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/details)标签包装。该标签可用于折叠的html内容

先安装[react-use][react-use]

```bash
pnpm add react-use
```

:::info

这里我们用到了[react-use][react-use]中的`useMount`，这个钩子可以在第一次渲染后执行里面的内容。类似于`useEffect(...,[])`

:::

```tsx
// src/app/_components/collapsible/details.tsx
'use client';
// ...
import { useMount } from 'react-use';
import $styles from './details.module.css';

export const Details: FC<PropsWithChildren<{ defaultOpen?: boolean; summary: string }>> = ({
    defaultOpen = false,
    summary,
    children,
}) => {
    const [open, setOpen] = useState(defaultOpen);
    const detailsRef = useRef<HTMLDetailsElement>(null);
    const contentRef = useRef<HTMLDivElement>(null);

    const openDetails = useCallback((isInit = false) => {
        if (detailsRef.current && contentRef.current) {
            detailsRef.current.setAttribute('open', '');
            contentRef.current.style.maxHeight = `${contentRef.current.scrollHeight}px`;
            if (isInit) setOpen(true);
            else {
                contentRef.current.addEventListener(
                    'transitionend',
                    () => {
                        setOpen(true);
                    },
                    { once: true },
                );
            }
        }
    }, []);

    const closeDetails = useCallback((isInit = false) => {
        if (detailsRef.current && contentRef.current) {
            contentRef.current.style.maxHeight = '0px';
            setOpen(false);
            if (isInit) detailsRef.current.removeAttribute('open');
            else {
                contentRef.current.addEventListener(
                    'transitionend',
                    () => {
                        detailsRef.current?.removeAttribute('open');
                    },
                    { once: true },
                );
            }
        }
    }, []);

    const handleToggle: MouseEventHandler<HTMLElement> = useCallback(
        (e) => {
            e.preventDefault();
            open ? closeDetails() : openDetails();
        },
        [open],
    );

    useMount(() => {
        open ? openDetails(true) : closeDetails(true);
        if (contentRef.current) contentRef.current.style.transition = 'max-height 0.3s ease-out';
    });

    return (
        <details className={$styles.details} ref={detailsRef}>
            <summary className="tw-cursor-pointer" onClick={handleToggle}>
                {summary}
            </summary>
            <div ref={contentRef} className={clsx($styles.content)}>
                {children}
            </div>
        </details>
    );
};
```

样式如下

```css
/* src/app/_components/collapsible/details.module.css */
.details {
    @apply tw-border tw-p-2 tw-overflow-hidden;

    & > .content {
        @apply tw-overflow-hidden tw-px-2 tw-py-3;
    }
}
```

编写表单组件

可以看到，对于表单的提交。在编辑页面时，我们直接使用表单内部提交即可。这是，因为编辑表单嵌套在modal里面。但为了样式更好看些，创建表单的提交按钮我们放在外部一个单独的表单创建页面中。所以，创建文章数据的提交也需要对外部组件做一个开放接口，通过前面的课程我们已知，这可以通过`useImperativeHandle`来实现

另外，在提交表单后数据操作完成前，也可以给用户一个”正在处理中”的反馈。这时候，可以禁用输入框和提交按钮等，以免用户重复操作，这也是一个用户体验友好的表单必不可少的。使用`form.formState.isSubmitting`就可以判断表单是否处于提交中（数据处理中）的状态，从而对输入框和按钮进行操作。以下为具体实现，可以看到在表单数据处理时

- 通过`form.formState.isSubmitting`+`disable`来实现禁用输入框
- 修改`generateTitleSlug`函数，判断`form.formState.isSubmitting`来确定是否禁用自动生成`slug`函数的功能（同时，最好给`Link`也添加上`aria-disabled={form.formState.isSubmitting}`）
- 判断`form.formState.isSubmitting`来确定是否禁用提交按钮以及按钮显示的文字

代码如下

```tsx
// src/app/_components/post/action-form.tsx
'use client';
// ...

export const PostActionForm = forwardRef<PostCreateFormRef, PostActionFormProps>((props, ref) => {
    const form = usePostActionForm(
        props.type === 'create' ? { type: props.type } : { type: props.type, item: props.item },
    );

    const submitHandler = usePostFormSubmitHandler(
        props.type === 'create' ? { type: 'create' } : { type: 'update', id: props.item.id },
    );

    useEffect(() => {
        if (props.type === 'create' && !isNil(props.setPedding))
            props.setPedding(form.formState.isSubmitting);
    }, [form.formState.isSubmitting]);

    useImperativeHandle(
        ref,
        () =>
            props.type === 'create'
                ? {
                      create: form.handleSubmit(submitHandler),
                  }
                : {},
        [props.type],
    );

    return (
        <Form {...form}>
            <form onSubmit={form.handleSubmit(submitHandler)} className="tw-space-y-8">
                <FormField
                    control={form.control}
                    name="title"
                    render={({ field }) => (
                        <FormItem>
                            <FormLabel>文章标题</FormLabel>
                            <FormControl>
                                <Input
                                    {...field}
                                    placeholder="请输入标题"
                                    disabled={form.formState.isSubmitting}
                                />
                            </FormControl>
                            <FormMessage />
                        </FormItem>
                    )}
                />
                <Details summary="可选字段" defaultOpen>
                    <FormField
                        control={form.control}
                        name="summary"
                        render={({ field }) => (
                            <FormItem className="tw-mt-2 tw-border-b tw-border-dashed tw-pb-1">
                                <FormLabel>摘要简述</FormLabel>
                                <FormControl>
                                    <Textarea
                                        {...field}
                                        placeholder="请输入文章摘要"
                                        disabled={form.formState.isSubmitting}
                                    />
                                </FormControl>
                                <FormDescription>摘要会显示在文章列表页</FormDescription>
                                <FormMessage />
                            </FormItem>
                        )}
                    />
                </Details>
                <FormField
                    control={form.control}
                    name="body"
                    render={({ field }) => (
                        <FormItem>
                            <FormLabel>文章内容</FormLabel>
                            <FormControl>
                                <Textarea
                                    placeholder="请输入内容"
                                    {...field}
                                    className="tw-min-h-80"
                                />
                            </FormControl>
                            <FormMessage />
                        </FormItem>
                    )}
                />
                {props.type === 'update' && (
                    <Button type="submit" disabled={form.formState.isSubmitting}>
                        {form.formState.isSubmitting ? '更新中...' : '保存'}
                    </Button>
                )}
            </form>
        </Form>
    );
});
```

现在，对于编辑页面，我们只要在`src/app/(pages)/@modal/post-edit/[item]/page.tsx`中添加该表单就能实现文章更新功能了

```tsx
// src/app/(pages)/@modal/post-edit/[item]/page.tsx
// ...
const PostEditPage: FC<{ params: Promise<{ item: string }> }> = async ({ params }) => {
    const { item } = await params;
    if (isNil(item)) return notFound();

    return (
        <PageModal
            title="编辑文章"
            match={['/post-edit/*']}
            className="tw-min-w-full lg:tw-min-w-[60%]"
        >
            <PostEditForm id={item} />
        </PageModal>
    );
};

export default PostEditPage;
```

这里把编辑页和编辑表单分开（多加了一个编辑表单组件）的目的是因为后续我们需要对编辑表单做一些客户端组件所需要的处理。比如在文章找不到时，返回`404`页面等工作。然后把这个文章编辑表单放入前面的文章编辑模态页面中即可

```tsx
// src/app/(pages)/@modal/post-edit/[item]/form.tsx
// ...
import { PostActionForm } from '@/app/_components/post/action-form';

export const PostEditForm: FC<{ id: string }> = async ({ id }) => {
    const post = await queryPostItemById(id);
    if (isNil(post)) return notFound();
    return <PostActionForm type="update" item={post} />;
};

// src/app/(pages)/@modal/post-edit/[item]/page.tsx
// ...
const PostEditPage: FC<{ params: Promise<{ item: string }> }> = async ({ params }) => {
    const { item } = await params;
    if (isNil(item)) return notFound();

    return (
        <PageModal
            title="编辑文章"
            match={['/post-edit/*']}
            className="tw-min-w-full lg:tw-min-w-[60%]"
        >
            <PostEditForm id={item} />
        </PageModal>
    );
};

export default PostEditPage;
```

对于文章创建页面，我们同样分开编写表单和页面

:::warning

请注意：由于文章创建页面后续会涉及到`cookies`的用户权限，所以我们预先加入`export const dynamic = 'force-dynamic';`这个标记来强制ssr，不然会出现缓存我们。现在只需加入即可，不必理会，即使不加也不影响本节课的功能

:::

```tsx
// src/app/(pages)/posts/create/form.tsx
'use client';
// ...
import { Save } from 'lucide-react';
import $styles from './style.module.css';

export const PostCreateForm: FC = () => {
    const ref = useRef<PostCreateFormRef | null>(null);
    const [pedding, setPedding] = useState(false);
    const changePadding = useCallback((value: boolean) => {
        setPedding(value);
    }, []);
    const createPost = useCallback<MouseEventHandler<HTMLButtonElement>>(async (e) => {
        e.preventDefault();
        ref.current?.create && (await ref.current?.create());
    }, []);
    return (
        <>
            <div className={$styles.actions}>
                <BackButton />
                <Button onClick={createPost} disabled={pedding}>
                    {pedding ? '保存中...' : '保存'}
                    <Save />
                </Button>
            </div>
            <PostActionForm ref={ref} type="create" setPedding={changePadding} />
        </>
    );
};

// src/app/(pages)/posts/create/page.tsx
// ...
import $styles from './style.module.css';

// 添加动态标记，强制使用 SSR
export const dynamic = 'force-dynamic';

const PostCreatePage: FC = async () => {
    return (
        <div className="tw-page-container">
            <div className={$styles.item}>
                <PostCreateForm />
            </div>
        </div>
    );
};
export default PostCreatePage;
```

编写一些文章创建页面和表单的样式

```css
/* src/app/(pages)/posts/create/style.module.css */
.item {
    @apply tw-flex tw-flex-auto tw-flex-col tw-space-y-6  tw-bg-white/90  tw-min-w-full lg:tw-min-w-[60%] !tw-max-w-full tw-px-5 tw-py-3 tw-rounded-md;
}

.actions {
    @apply tw-flex tw-justify-between;
}

html[class='dark'] {
    .item {
        @apply tw-bg-black/80;
    }
}
```

#### 文章展示页面

文章展示页面没什么逻辑，就不再赘述了，直接上代码

:::info

唯一需要注意的是，在找不到文章时，显示404页面

:::

```tsx
// src/app/(pages)/posts/[item]/page.tsx
// ...
import { Calendar } from 'lucide-react';
import Image from 'next/image';

import $styles from './page.module.css';

const PostItemPage: FC<{ params: Promise<{ item: string }> }> = async ({ params }) => {
    const { item } = await params;
    const post = await queryPostItem(item);
    if (isNil(post)) return notFound();
    return (
        <div className="tw-page-container">
            <Tools back />
            <div className={$styles.item}>
                <div className={$styles.thumb}>
                    <Image
                        src={post.thumb}
                        alt={post.title}
                        fill
                        priority
                        sizes="100%"
                        unoptimized
                    />
                </div>

                <div className={$styles.content}>
                    <header className={$styles.title}>
                        <h1>{post.title}</h1>
                    </header>
                    <div className={$styles.meta}>
                        <div>
                            <span>
                                <Calendar />
                            </span>
                            <time className="tw-ellips">2024年8月10日</time>
                        </div>
                    </div>
                    <div className={$styles.body}>{post.body}</div>
                </div>
            </div>
        </div>
    );
};
export default PostItemPage;
```

样式

```css
/* src/app/(pages)/posts/[item]/page.module.css */
.item {
    @apply tw-bg-white/80 dark:tw-bg-zinc-800/80 tw-flex-auto tw-w-full tw-drop-shadow-lg tw-rounded-md tw-flex tw-flex-col;

    & > .thumb {
        @apply tw-relative tw-w-full tw-h-36 md:tw-h-48 lg:tw-h-64 tw-block;
    }

    & > .thumb img {
        @apply tw-rounded-tl-md tw-rounded-tr-md tw-opacity-60;
    }

    & > .content {
        @apply tw-p-3 tw-flex tw-flex-col;

        & > .title {
            @apply tw-my-2;
        }

        & > .meta {
            @apply tw-flex tw-my-2 tw-justify-between;

            & > div {
                @apply tw-flex tw-items-center;
            }

            & time {
                @apply tw-ml-2;
            }
        }
    }
}
```

### 最终效果

最后，我们来看一下最终的应用是怎样的

![](https://cn-nb1.rains3.com/3rcd/media/1735762951622.gif)
