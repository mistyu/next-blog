[react-use]: https://github.com/streamich/react-use
[zod]: https://zod.dev/
[suspense]: https://react.dev/reference/react/Suspense
[pinyin]: https://github.com/hotoo/pinyin
[toast]: https://ui.shadcn.com/docs/components/toast
[source]: https://git.3rcd.com/classroom/ts-fullstack/src/branch/main/chapter8

## 导读

:::note

本节课源码: [classroom/ts-fullstack/chapter8][source]（请[登录](https://git.3rcd.com/user/login?redirect_to=%2f)后查看或克隆，否则你将收到**404 NotFound**）

:::

本节课程我们不追究太多新功能，而是对应用进行优化以提升用户体验和SEO等

### 课程目标

这节课的学习目标以提升用户体验为主，学习以下知识

- 改进界面，实现响应式（平板、移动端设备自适应）等效果
- 学习SEO常用的标题、关键字、描述等标签的用途以及在next.js中如何定义它们
- 改变文章详情页的URL，使页面对搜索引擎友好
- 使用[zod][zod]对表单字段进行数据验证，同时，学会自定义验证与异步远程验证
- 自定义404页面以及捕获异常后弹出错误消息或显示错误页面
- 增加骨架屏以显示loding效果与掌握[Suspense][suspense]组件的简单使用

### 技术概念

本节课涉及到以下技术概念

- [use-media](https://github.com/streamich/react-use/blob/master/docs/useMedia.md): 一个可以根据屏幕尺寸判断当前设备的hook
- [zod][zod]：一个非常流行的数据验证库
- [pinyin][pinyin]：个库可以把汉字翻译成拼音
- [toast][toast]组件：用于弹出消息框

### 前置准备

在学习本课程前，修复一下前面课程中的一个样式问题

```css
/* src/app/(pages)/posts/[item]/page.module.css */
/* ... */
.item {
    /* ... */
    /* 加一个tw-flex-auto */
    & > .content {
        @apply tw-p-3 tw-flex tw-flex-col tw-flex-auto;
    }
}
```

去除多余的div

```tsx
// src/app/(pages)/posts/[item]/page.tsx
// ...
const PostItemPage: FC<{ params: Promise<{ item: string }> }> = async ({ params }) => {
    // ...
                <div className={$styles.content}>
                    {/* 去除<div className={$styles.body}> */}
                    <header className={$styles.title}>
                        <h1>{post.title}</h1>
                    </header>
                   {/* ... */}
            </div>
        </div>
    );
};
export default PostItemPage;
```

## 界面优化

我们对原来的UI做一些修改，以获得更佳的视觉效果。并使界面支持响应式，这样可以在移动端有更好的用户体验

### Header组件

添加一个移动或平板状态下的导航栏组件

:::info

别忘了复制[nav.module.css](https://git.3rcd.com/classroom/ts-fullstack/src/branch/main/chapter8/src/app/_components/header/nav.module.css)中的内容以覆盖`src/app/_components/header/nav.module.css`中的原有样式

:::

```tsx
// src/app/_components/header/nav.tsx
// ...
import { House } from 'lucide-react';

const items = [
    {
        title: '首页',
        href: '/',
        // 添加一个链接图标
        icon: House,
    },
];

/**
 * 桌面端导航栏
 */
export const HeaderNav: FC = () => (
    {/* ... */}
                            <NavigationMenuLink className={cn(navigationMenuTriggerStyle())}>
                                {/* 添加一个链接图标 */}
                                {item.icon && <item.icon className="tw-mr-1" />}
                                {item.title}
                            </NavigationMenuLink>
    {/* ... */}
);

/**
 * 平板和移动端导航栏
 */
export const MobileNav: FC = () => (
    <div className={$styles.mobileNav}>
        <ul>
            {items.map((item) => (
                <li key={item.href} className={$styles['mobile-menu-item']}>
                    {item.icon && <item.icon className="tw-mr-2" />}
                    <Link href={item.href}>{item.title}</Link>
                </li>
            ))}
        </ul>
    </div>
);

```

修改Logo组件和HeaderTools组件的样式，如下

```css
/* src/app/_components/header/logo.module.css */
.logo {
    @apply tw-flex tw-items-center tw-w-24;
}

.logo > a {
    @apply tw-block tw-w-auto tw-h-auto;
}

/* src/app/_components/header/tools.module.css */
.tools {
    @apply tw-flex tw-gap-4 tw-items-center;
}
```

修改文章创建按钮，让其在移动端（新增的`iconBtn`为`true`）的状态下，仅显示一个"+"图标

:::note

这里，我们顺带抽象出了`useUrlQuery`用于获取浏览器地址栏中的query参数

:::

```tsx
// src/libs/url.ts
// ...
export const useUrlQuery = () => {
    const searchParams = useSearchParams();
    return useMemo(() => {
        const query = new URLSearchParams(searchParams.toString()).toString();
        return isNil(query) || query.length < 1 ? '' : `?${query}`;
    }, [searchParams]);
};

// src/app/_components/post/create-button.tsx
// ...
export const Button: FC<{ iconBtn?: boolean }> = ({ iconBtn }) => {
    const urlQuery = useUrlQuery();
    return (
        <CNButton
            asChild
            className={cn('tw-ml-auto tw-justify-end', {
                'focus-visible:!tw-ring-0': !iconBtn,
                'tw-rounded-sm': !iconBtn,
            })}
            variant="outline"
            size={iconBtn ? 'icon' : 'default'}
        >
            <Link href={`/posts/create${urlQuery}`}>
                <Plus />
                {!iconBtn && '创建'}
            </Link>
        </CNButton>
    );
};

export const PostCreateButton: FC<{ iconBtn?: boolean }> = ({ iconBtn = false }) => (
    <Suspense>
        <Button iconBtn={iconBtn} />
    </Suspense>
);
```

修改HeaderTools组件

```tsx
// src/app/_components/header/tools.tsx
export const HeaderTools: FC<{ isMobile?: boolean }> = ({ isMobile = false }) => {
    return (
        <div className={$styles.tools}>
            <div className="tw-flex">
                <PostCreateButton iconBtn={isMobile} />
            </div>
            <ShadcnThemeSetting />
        </div>
    );
};
```

添加一个透明图标按钮的样式

```css
/* src/app/styles/tailwind/components.css */
@layer components {
    /* ... */
    /* 全透明图标按钮 */
    .tw-btn-icon-transparent {
        @apply tw-block !tw-w-auto !tw-border-none !tw-bg-transparent !tw-shadow-none !tw-ring-0 hover:!tw-bg-transparent focus-visible:!tw-ring-0;
    }
}
```

添加一个移动端的Header组件

```tsx
// src/app/_components/header/mobile.tsx
// ...
import $styles from './styles.module.css';
/**
 * 在打开移动端导航栏时，显示一个模态背景
 * 通过点击它也可以折叠导航栏
 * @param param0
 */
const Modal: FC<{ close: MouseEventHandler<HTMLDivElement>; open: boolean }> = ({
    close,
    open,
}) => {
    const noAction = useCallback<KeyboardEventHandler<HTMLDivElement>>((e) => {
        e.preventDefault();
    }, []);
    return (
        <div
            className={cn($styles.modal, { [$styles.open]: open })}
            role="button"
            tabIndex={0}
            onClick={close}
            onKeyDown={noAction}
        ></div>
    );
};

/**
 * 移动端导航栏
 * @param param0
 */
export const MobileHeader: FC<{ open: boolean; setOpen: (value: boolean) => void }> = (props) => {
    const { open, setOpen } = props;
    const close = useCallback<MouseEventHandler<HTMLDivElement | HTMLButtonElement>>((e) => {
        e.preventDefault();
        setOpen(false);
    }, []);
    return (
        <>
            <div className={cn($styles.side, { [$styles.open]: open })}>
                <div className={$styles.top}>
                    <HeaderLogo />
                    <Button
                        variant="outline"
                        size="icon"
                        className={cn('tw-btn-icon-transparent')}
                        onClick={close}
                    >
                        <X />
                    </Button>
                </div>
                <div className={$styles.content}>
                    <MobileNav />
                </div>
            </div>
            {createPortal(<Modal close={close} open={open} />, document.body)}
        </>
    );
};
```

其样式如下

```css
/* src/app/_components/header/mobile.module.css */
.side,
.modal {
    @apply tw-hidden;
}

.side {
    @apply tw-fixed tw-flex tw-flex-col tw-h-screen tw-w-60 tw-z-[999] 
           tw-bg-[rgb(255_255_255/0.8)] dark:tw-bg-[rgba(24_24_27/0.9)] tw-bg-opacity-90 tw-backdrop-blur-sm
           tw-transition-transform tw-duration-300 tw-ease-out  -tw-translate-x-full;

    & > .top {
        @apply tw-flex tw-flex-none tw-items-center tw-justify-between tw-px-4 tw-h-10 tw-shadow-[rgba(0_0_0/0.1)_0px_1px_2px_0px];
    }

    & > .content {
        @apply tw-flex-auto;
    }

    &.open {
        @apply tw-translate-x-0;
    }
}

.modal.open {
    @apply tw-block tw-fixed tw-inset-0 tw-bg-black/50 tw-z-50;
}
```

使用[react-use][react-use]中的`useMedia`添加屏幕节点判断钩子

```ts
// src/libs/broswer.ts
// ...
import { useMedia } from 'react-use';

/**
 * 屏幕尺寸检测值
 */
const screenSize = {
    xs: 480,
    sm: 576,
    md: 768,
    lg: 992,
    xl: 1200,
    '2xl': 1400,
};

/**
 * 检测当前屏幕尺寸
 * @param key
 */
export function useScreenCheck(key: keyof typeof screenSize) {
    return useMedia(`(max-width: ${screenSize[key]}px)`, false);
}

/**
 * 根据屏幕尺寸检测当前设备是否为移动端
 */
export function useIsMobile() {
    return useScreenCheck('md');
}

/**
 * 根据屏幕尺寸检测当前设备是否为平板
 */
export function useIsTablet() {
    const isMobile = useIsMobile();
    const lg = useScreenCheck('lg');
    return !isMobile && lg;
}

/**
 * 根据屏幕尺寸检测当前设备是否为笔记本
 */
export function useIsNotebook() {
    const isTablet = useIsTablet();
    const xl = useScreenCheck('xl');
    return !isTablet && xl;
}

/**
 * 根据屏幕尺寸检测当前设备是否为台式机
 */
export function useIsPC() {
    return useMedia(`(min-width: ${screenSize.xl}px)`);
}

/**
 *  根据屏幕尺寸检测当前设备是否为桌面端
 */
export function useIsDesktop() {
    const isNotebook = useIsNotebook();
    const isPc = useIsPC();
    return isNotebook || isPc;
}
```

修改Header组件，在移动和桌面状态下启用不同的导航栏组件

:::info

别忘了复制[style.module.css](https://git.3rcd.com/classroom/ts-fullstack/src/branch/main/chapter8/src/app/_components/header/styles.module.css)中的内容以覆盖`src/app/_components/header/style.module.css`中的原有样式

:::

```tsx
// src/app/_components/header/index.tsx
// ...
export const Header: FC = () => {
    const scrolled = useScroll(50);
    const [mobileOpen, setMobileOpen] = useState(false);
    const toggleMobile = useCallback(() => setMobileOpen(!mobileOpen), [mobileOpen]);
    const mobile = useIsMobile();
    const tablet = useIsTablet();
    // 在平板设备和移动设备的屏下均设为移动设备状态
    const isMobile = useMemo(() => mobile || tablet, [mobile, tablet]);
    useEffect(() => {
        const element = document.querySelector('html');
        if (!isNil(element) && isMobile) {
            if (mobileOpen) element.style.overflow = 'hidden';
            else element.style.removeProperty('overflow');
        }
    }, [mobileOpen, isMobile]);
    return (
        <>
            <header
                className={cn($styles.header, {
                    [$styles['header-scrolled']]: scrolled,
                    [$styles['header-unscrolled']]: !scrolled,
                })}
            >
                <div className={cn($styles.container)}>
                    <div className={$styles.logo}>
                        <Button
                            variant="outline"
                            size="icon"
                            className={cn('tw-btn-icon-transparent', $styles.mobileCollapse)}
                            onClick={toggleMobile}
                        >
                            <List />
                        </Button>
                        <HeaderLogo />
                    </div>
                    <div className={cn('tw-block-container ', $styles.nav)}>
                        <HeaderNav />
                    </div>
                    <div className={$styles.tools}>
                        <HeaderTools isMobile={isMobile} />
                    </div>
                </div>
            </header>
            {isMobile && <MobileHeader open={mobileOpen} setOpen={setMobileOpen} />}
        </>
    );
};
```

修改一下文章列表页的`footer`样式以自适应

```css
/* src/app/(pages)/page.module.css */
/* ... */
& > .footer {
    @apply tw-py-3 tw-flex tw-justify-between tw-text-muted-foreground tw-flex-wrap tw-space-y-3 md:tw-space-y-0;
    /* ... */
}
```

效果如下

![](https://cn-nb1.rains3.com/3rcd/media/1737184210034.gif)

### MDX渲染器

修改Mdx渲染器，使TOC目录适配移动端

把`src/app/_components/mdx/components/toc.tsx`的内容复制到一个新增的`src/app/_components/mdx/components/toc/list.tsx`的文件中，并进行一些小修改，具体代码请直接复制[源码](https://git.3rcd.com/classroom/ts-fullstack/src/branch/main/chapter8/src/app/_components/mdx/components/toc/list.tsx)。并复制[list.module.css](https://git.3rcd.com/classroom/ts-fullstack/src/branch/main/chapter8/src/app/_components/mdx/components/toc/list.module.css)到`src/app/_components/mdx/components/toc/list.module.css`中。然后删除原来的`src/app/_components/mdx/components/toc.tsx`和`src/app/_components/mdx/components/toc.module.css`

```tsx
// src/app/_components/mdx/components/toc/list.tsx
// ...
import $styles from './list.module.css';

interface Props {
    toc: TocItem[];
    maxDepth?: HeadingDepth;
    indented?: boolean;
    ordered?: boolean;
    tight?: boolean;
    exclude?: string | string[];
    skipLevels?: HeadingDepth[];
    skipParents?: Exclude<HeadingParent, 'root'>[];
}

export const TocList: FC<Props> = ({ ... })
```

lucide-react图标库不够用，所以新增一个图标库：xicon。我们这里安装xicon的fluent图标库

```bash
pnpm add @ricons/fluent
```

编写xicon图标样式

```css
/* src/app/styles/app.css */
/* ... */
.xicon {
    @apply tw-w-[1em] tw-h-[1em] tw-inline-flex;

    & svg {
        @apply !tw-w-full !tw-h-full;

        &:not([fill]) {
            fill: currentcolor;
        }
    }
}
```

添加一个透明滚动条样式

```css
/* src/app/styles/tailwind/utilities.css */
@layer utilities {
    /* ... */
    /* 透明滚动条 */
    .tw-transparent-scrollbar {
        &::-webkit-scrollbar {
            @apply tw-w-1 tw-h-1;
        }

        &::-webkit-scrollbar-track {
            @apply tw-bg-gray-100 dark:tw-bg-zinc-800;
        }

        &::-webkit-scrollbar-thumb {
            @apply tw-bg-gray-300 dark:tw-bg-zinc-600 tw-rounded;
        }

        &::-webkit-scrollbar-corner {
            @apply tw-bg-gray-100 dark:tw-bg-zinc-800;
        }
    }
}
```

编写新的Toc组件

```tsx
// src/app/_components/mdx/components/toc/index.tsx
// ...
import BookNumber24Filled from '@ricons/fluent/BookNumber24Filled';
import { NotepadText, X } from 'lucide-react';
import $styles from './style.module.css';

/**
 * 桌面设备下的目录组件
 * @param props
 */
const DesktopToc: FC<{ serialized: MdxHydrateProps['serialized'] }> = (props) => {
    const { serialized } = props;
    if (isNil(serialized.scope?.toc) || serialized.scope?.toc.length < 1) return null;
    return (
        <div className={$styles.desktopToc}>
            <TocList toc={serialized.scope.toc} />
        </div>
    );
};

/**
 * 移动或平板设备下的目录组件
 * @param props
 */
const MobileToc: FC<{ serialized: MdxHydrateProps['serialized'] }> = (props) => {
    const [collapsed, setCollapsed] = useState(true);
    const toggleCollapsed = useCallback(() => setCollapsed((prev) => !prev), []);
    const close = useCallback(() => setCollapsed(true), []);
    return (
        <div
            className={cn($styles.mobileToc, {
                [$styles['mobileToc-collapsed']]: collapsed,
                [$styles['mobileToc-expanded']]: !collapsed,
            })}
        >
            <Button
                variant="outline"
                size="icon"
                className={cn('tw-btn-icon-transparent', $styles.mobileTocButton)}
                onClick={toggleCollapsed}
            >
                <span className="xicon tw-text-2xl">
                    <BookNumber24Filled />
                </span>
            </Button>
            <div className={$styles.mobileTocMain}>
                <div className={$styles.mobileTocTitle}>
                    <div className="tw-flex tw-items-center">
                        <NotepadText className="tw-mr-1" />
                        目录
                    </div>
                    <div className="tw-block tw-items-center">
                        <Button
                            variant="outline"
                            size="icon"
                            className={cn('tw-btn-icon-transparent')}
                            onClick={close}
                        >
                            <X />
                        </Button>
                    </div>
                </div>
                <div className={cn($styles.mobileTocContent, 'tw-transparent-scrollbar')}>
                    <DesktopToc {...props} />
                </div>
            </div>
        </div>
    );
};

export const Toc: FC<{ serialized: MdxHydrateProps['serialized']; isMobile: boolean }> = (
    props,
) => {
    const { isMobile, serialized } = props;
    return isMobile ? (
        <MobileToc serialized={serialized} />
    ) : (
        <DesktopToc serialized={serialized} />
    );
};
```

添加组件样式

```css
/* src/app/_components/mdx/components/toc/style.module.css */
.desktopToc {
    @apply tw-w-56 tw-flex-shrink-0 tw-sticky tw-top-16 tw-self-start;
}

.mobileToc {
    @apply tw-fixed tw-flex tw-items-center tw-right-0 tw-top-16 tw-z-10 tw-top-[30%] tw-overflow-hidden 
    tw-transition-transform tw-duration-300 tw-ease-out;

    & > .mobileTocButton > span > svg {
        filter: drop-shadow(1px 2px 1px rgb(144 130 130 / 40%));
    }

    & > .mobileTocMain {
        @apply tw-h-full tw-w-56 tw-bg-[rgb(255_255_255/0.8)] dark:tw-bg-[rgba(24_24_27/0.9)] tw-backdrop-blur-sm tw-drop-shadow-sm
               tw-shadow-lg  tw-rounded-tl-lg tw-rounded-bl-lg tw-py-2;

        & > .mobileTocTitle {
            @apply tw-flex tw-items-center tw-py-2 tw-px-4 tw-justify-between;
        }

        & > .mobileTocContent {
            @apply tw-overflow-y-auto tw-overflow-x-hidden tw-max-h-96;
            direction: rtl;

            & > * {
                direction: ltr;
            }
        }
    }

    &.mobileToc-expanded {
        @apply tw-translate-x-0;
    }

    &.mobileToc-collapsed {
        @apply tw-translate-x-[calc(100%-1.5rem)];
    }
}
```

修改水合组件

```tsx
// src/app/_components/mdx/hydrate.tsx
// ...
export const MdxHydrate: FC<MdxHydrateProps> = (props) => {
    // ...
    const mobile = useIsMobile();
    const tablet = useIsTablet();
    const isMobile = useMemo(() => mobile || tablet, [mobile, tablet]);
    // ...
    if (isNil(serialized) || 'error' in serialized) return null;
    return (
        !isNil(content) && (
            <div className={$styles.container}>
                <div className={$styles.article} ref={contentRef}>
                    {content}
                </div>
                {toc && <Toc serialized={serialized} isMobile={isMobile} />}
            </div>
        )
    );
};
```

修改`src/app/_components/mdx/hydrate.module.css`样式

```css
.container {
    @apply tw-w-full tw-flex tw-gap-8 tw-relative;

    & > .article {
        @apply tw-flex-1 tw-min-w-0 tw-overflow-hidden;
    }
}
```

由于`tw-drop-shadow-*`样式会对`fixed`的容器范围产生影响，所以请务必把文章详情页样式中的`tw-drop-shadow-lg`改掉或去掉

```css
/* src/app/(pages)/posts/[item]/page.module.css */
.item {
    @apply tw-bg-white/80 dark:tw-bg-zinc-800/80 tw-flex-auto tw-w-full tw-shadow-lg tw-rounded-md tw-flex tw-flex-col;
    /* ... */
}
```

查看效果

![](https://cn-nb1.rains3.com/3rcd/media/1737188455540.gif)

给文章详情页添加一个编辑按钮。该按钮仅显示一个图标，但是在鼠标移上去的时候显示一段提示文字

安装shadcn的[tooltip](https://ui.shadcn.com/docs/components/tooltip)组件

```bash
pnpm addsc tooltip
```

编写组件

```tsx
// src/app/_components/post/edit-button.tsx
// ...
import DocumentEdit24Regular from '@ricons/fluent/DocumentEdit24Regular';

const Button: FC<{ id: string; iconBtn?: boolean }> = ({ id, iconBtn }) => {
    const urlQuery = useUrlQuery();
    return (
        <CNButton
            asChild
            className={cn({
                'tw-mr-3': !iconBtn,
                'tw-btn-icon-transparent ': iconBtn,
            })}
            variant={iconBtn ? 'outline' : 'default'}
            size={iconBtn ? 'icon' : 'default'}
        >
            <Link href={`/posts/edit/${id}${urlQuery}`}>
                {iconBtn ? (
                    <span className="xicon tw-text-2xl">
                        <DocumentEdit24Regular />
                    </span>
                ) : (
                    <UserPen />
                )}
                {!iconBtn && ' 编辑'}
            </Link>
        </CNButton>
    );
};

export const PostEditButton: FC<{ id: string; iconBtn?: boolean }> = ({ id, iconBtn }) => (
    <Suspense>
        {iconBtn ? (
            <TooltipProvider>
                <Tooltip>
                    <TooltipTrigger>
                        <Button id={id} iconBtn />
                    </TooltipTrigger>
                    <TooltipContent>
                        <p>编辑文章</p>
                    </TooltipContent>
                </Tooltip>
            </TooltipProvider>
        ) : (
            <Button id={id} />
        )}
    </Suspense>
);
```

修改文章详情页

```tsx
// src/app/(pages)/posts/[item]/page.tsx
// ...
<header className={$styles.title}>
    <h1 className="tw-text-lg lg:tw-text-3xl">{post.title}</h1>
    <div className="tw-ml-2">
        <PostEditButton id={post.id} iconBtn />
    </div>
</header>
```

修改`title`样式

```css
/* src/app/(pages)/posts/[item]/page.module.css */
/* ... */
& > .title {
    @apply tw-my-2 tw-flex;
}
```

![](https://cn-nb1.rains3.com/3rcd/media/1737189292963.png)

在桌面模式下，可以把TOC和文章内容提到一个水平线可以得到更好的视觉效果

:::note

这一步不是必须的，按自己需求编写即可

:::

修改水合组件和渲染组件的参数类型

```ts
// src/app/_components/mdx/types.ts
// ...
/**
 * mdx水合组件props
 */
export interface MdxHydrateProps extends MdxHydrateOptions {
    header?: React.ReactNode;
    serialized: SerializeResult<Record<string, unknown>, Scope>;
}

/**
 * mdx渲染器组件props
 */
export interface MdxRnderProps {
    source: Compatible;
    header?: React.ReactNode;
    options?: MdxSerializeOptions;
    hydrate?: MdxHydrateOptions;
}
```

修改MDX组件

```tsx
// src/app/_components/mdx/hydrate.tsx
// ...
export const MdxHydrate: FC<MdxHydrateProps> = (props) => {
    const { serialized, header, toc = true, ...rest } = props;
    // ...
    return (
        !isNil(content) && (
            <div className={$styles.container}>
                <div className={$styles.article} ref={contentRef}>
                    {header}
                    {content}
                </div>
                {toc && <Toc serialized={serialized} isMobile={isMobile} />}
            </div>
        )
    );
};

// src/app/_components/mdx/render.tsx
// ...
export const MdxRender: FC<MdxRnderProps> = async (props) => {
    const { source, options, hydrate, header } = props;
    const result = await serializeMdx(source, options ?? {});
    return <MdxHydrate {...(hydrate ?? {})} serialized={result} header={header} />;
};
```

修改文章详情页，把`title`和`meta`移动到`MdxRender`中

```tsx
// src/app/(pages)/posts/[item]/page.tsx
// ...
import $styles from './page.module.css';

const PostItemPage: FC<{ params: Promise<{ item: string }> }> = async ({ params }) => {
    // ...

    return (
        <div className="tw-page-container">
            {/* ... */}

                <div className={$styles.content}>
                   <MdxRender
                    source={post.body}
                    header={
                        <>
                            <header className={$styles.title}>
                                <h1 className="tw-text-lg lg:tw-text-3xl">{post.title}</h1>
                                <div className="tw-ml-2">
                                    <PostEditButton id={post.id} iconBtn />
                                </div>
                            </header>
                            <div className={$styles.meta}>
                                <div>
                                    <span>
                                        <Calendar />
                                    </span>
                                    <time className="tw-ellips">
                                        {!isNil(post.updatedAt)
                                            ? formatChineseTime(new Date(post.updatedAt))
                                            : formatChineseTime(new Date(post.createdAt))}
                                    </time>
                                </div>
                            </div>
                        </>
                    }
                />
               {/* ... */}
    );
};
export default PostItemPage;
```

把`title`和`meta`的样式提到顶级

```css
/* src/app/(pages)/posts/[item]/page.module.css */
/* ... */
.title {
    /* ... */
}

.meta {
    /* ... */
}
```

![](https://cn-nb1.rains3.com/3rcd/media/1737190061321.png)

### MDX编辑器

修改编辑器，实现两个效果

- 在初始化编辑器（第一次序列化内容）前，显示一个loading效果
- 在移动端，只显示编辑框和预览框其中一者，而不是两栏，且默认是编辑框

编写一个Loading组件

:::info

别忘了复制[spinner.module.css](https://git.3rcd.com/classroom/ts-fullstack/src/branch/main/chapter8/src/app/_components/loading/spinner.module.css)中的内容以覆盖`src/app/_components/loading/spinner.module.css`中的原有样式

:::

```tsx
// src/app/_components/loading/spinner.tsx
// ...
import classes from './spinner.module.css';

export const Spinner: FC<{ className?: string; style?: CSSProperties }> = ({
    className,
    style,
}) => {
    const defaultClassName = cn([
        'tw-h-full',
        'tw-w-full',
        'tw-flex',
        'tw-items-center',
        'tw-justify-center',
    ]);
    const wrapperClasses = className ? `${defaultClassName} ${className}` : defaultClassName;
    return (
        <div className={wrapperClasses} style={style ?? {}}>
            <div className={classes.container} />;
        </div>
    );
};
```

修改编辑器组件

```tsx
// src/app/_components/mdx/editor.tsx
// ...
export const MdxEditor: FC<MdxEditorProps> = (props) => {
    // ...

    return (
        <div ref={containerRef} data-color-mode={theme} className={$styles.container}>
            {isNil(serialized) ? (
                <Spinner className="tw-rounded-sm tw-bg-white/80 tw-transition-opacity tw-duration-300 dark:tw-bg-black/50" />
            ) : (
                <>
                    <div className="wmde-markdown-var"> </div>
                    <MDEditor
                    // ...
                    />
                </>
            )}
        </div>
    );
};
```

![](https://cn-nb1.rains3.com/3rcd/media/1737191020647.gif)

接下来，实现第二个效果

```tsx
// src/app/_components/mdx/editor.tsx
// ...
export const MdxEditor: FC<MdxEditorProps> = (props) => {
    // ...
    const isMobile = useIsMobile();

    const extraCommands = useMemo(() => {
        const data = [commands.codeEdit, commands.codePreview];
        if (!isMobile) data.push(commands.codeLive);
        data.push(commands.fullscreen);
        return data;
    }, [isMobile]);

    // ...

    return (
        <div ref={containerRef} data-color-mode={theme} className={$styles.container}>
            {isNil(serialized) ? (
                <Spinner className="tw-rounded-sm tw-bg-white/80 tw-transition-opacity tw-duration-300 dark:tw-bg-black/50" />
            ) : (
                <>
                    <div className="wmde-markdown-var"> </div>
                    <MDEditor
                        preview={isMobile ? 'edit' : 'live'}
                        extraCommands={extraCommands}
                        value={content}
                        onChange={setContent}
                        height={editorHeight}
                        minHeight={editorHeight}
                        textareaProps={{ disabled }}
                        visibleDragbar
                        components={{
                            preview: () => <MdxHydrate serialized={serialized} toc={false} />,
                        }}
                    />
                </>
            )}
        </div>
    );
};
```

查看效果

![](https://cn-nb1.rains3.com/3rcd/media/1737191900262.gif)

## SEO

对文章做一些接单的SEO处理，在`header`标签的`meta`里放入一些常用的SEO信息。

### 修改模型

修改模型，添加`slug`（友好的文章详情页URL）、`keywords`（页面关键字）、`description`（页面描述）字段

:::info

`slug`要么为`null`要么具有唯一性

:::

```json
// src/database/schema/post.prisma
model Post {
    id          String   @id @default(uuid())
    thumb       String
    title       String
    summary     String?
    body        String
    slug        String?  @unique
    keywords    String?
    description String?
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt

    @@map("posts")
}
```

执行迁移命令

```bash
pnpm dbm && pnpm dbg
```

### 修改表单

把新增的数据库字段放到表单的`Details`组件中。这里值得注意的是，等会儿我们使用拼音库来自动生成`slug`，所以`slug`使用状态来控制

```tsx
// src/app/_components/post/action-form.tsx
// ...
export const PostActionForm = forwardRef<PostActionFormRef, PostActionFormProps>((props, ref) => {
    const [slug, setSlug] = useState(props.type === 'create' ? '' : props.item.slug || '');
    const changeSlug: ChangeEventHandler<HTMLInputElement> = useCallback(
        (e) => setSlug(e.target.value),
        [],
    );

    useEffect(() => {
        form.setValue('slug', slug);
    }, [slug]);

    // ...
    return (
        <Form {...form}>
            <form
                onSubmit={form.handleSubmit(submitHandler)}
                className="tw-flex tw-flex-auto tw-flex-col tw-space-y-8"
            >
                <FormField
                    control={form.control}
                    name="title"
                    render={({ field }) => (
                        <FormItem>
                            <FormLabel>文章标题</FormLabel>
                            <FormControl>
                                <Input
                                    {...field}
                                    placeholder="请输入标题"
                                    disabled={form.formState.isSubmitting}
                                />
                            </FormControl>
                            <FormMessage />
                        </FormItem>
                    )}
                />
                <Details summary="可选字段">
                    <FormField
                        control={form.control}
                        name="summary"
                        render={({ field }) => (
                            <FormItem className="tw-mt-2 tw-border-b tw-border-dashed tw-pb-1">
                                <FormLabel>摘要简述</FormLabel>
                                <FormControl>
                                    <Textarea
                                        {...field}
                                        placeholder="请输入文章摘要"
                                        disabled={form.formState.isSubmitting}
                                    />
                                </FormControl>
                                <FormDescription>摘要会显示在文章列表页</FormDescription>
                                <FormMessage />
                            </FormItem>
                        )}
                    />
                    <div className="tw-mt-2 tw-border-b tw-border-dashed tw-pb-1">
                        <FormField
                            control={form.control}
                            name="slug"
                            render={({ field }) => (
                                <FormItem className="">
                                    <FormLabel>唯一URL</FormLabel>
                                    <FormControl>
                                        <Input
                                            {...field}
                                            value={slug}
                                            onChange={changeSlug}
                                            placeholder="请输入唯一URL"
                                            disabled={form.formState.isSubmitting}
                                        />
                                    </FormControl>
                                    <FormDescription>
                                        如果留空,则文章访问地址是id
                                        <Link
                                            className="tw-ml-5 tw-mr-1 tw-text-black dark:tw-text-white"
                                            href="#"
                                            aria-disabled={form.formState.isSubmitting}
                                        >
                                            [点此]
                                        </Link>
                                        自动生成slug(根据标题使用&apos;-&apos;连接字符拼接而成,中文字自动转换为拼音)
                                    </FormDescription>
                                    <FormMessage />
                                </FormItem>
                            )}
                        />
                    </div>
                    <FormField
                        control={form.control}
                        name="keywords"
                        render={({ field }) => (
                            <FormItem className="tw-mt-2 tw-border-b tw-border-dashed tw-pb-1">
                                <FormLabel>关键字</FormLabel>
                                <FormControl>
                                    <Input
                                        {...field}
                                        placeholder="请输入关键字,用逗号分割(关键字是可选的)"
                                        disabled={form.formState.isSubmitting}
                                    />
                                </FormControl>
                                <FormDescription>
                                    关键字不会显示,仅在SEO时发挥作用.每个关键字之间请用英文逗号(,)分割
                                </FormDescription>
                                <FormMessage />
                            </FormItem>
                        )}
                    />
                    <FormField
                        control={form.control}
                        name="description"
                        render={({ field }) => (
                            <FormItem className="tw-mt-2 tw-border-b tw-border-dashed tw-pb-1">
                                <FormLabel>文章描述</FormLabel>
                                <FormControl>
                                    <Textarea
                                        {...field}
                                        placeholder="请输入文章描述"
                                        disabled={form.formState.isSubmitting}
                                    />
                                </FormControl>
                                <FormDescription>
                                    文章描述不会显示,仅在SEO时发挥作用
                                </FormDescription>
                                <FormMessage />
                            </FormItem>
                        )}
                    />
                </Details>
                {/* ... */}
            </form>
        </Form>
    );
});
```

修改表单的默认值，把新增的可选字段添加进去

```tsx
// src/app/_components/post/hooks.ts
// ...
export const usePostActionForm = (params: { type: 'create' } | { type: 'update'; item: Post }) => {
    // 定义默认数据
    const defaultValues = useMemo(() => {
        if (params.type === 'create') {
            return {
                title: '文章标题',
                body: '文章内容',
                summary: '',
                slug: '',
                keywords: '',
                description: '',
            } as DeepNonNullable<PostCreateData>;
        }

        return {
            title: params.item.title,
            body: params.item.body,
            summary: isNil(params.item.summary) ? '' : params.item.summary,
            slug: isNil(params.item.slug) ? '' : params.item.slug,
            keywords: isNil(params.item.keywords) ? '' : params.item.keywords,
            description: isNil(params.item.description) ? '' : params.item.description,
        } as DeepNonNullable<PostUpdateData>;
    }, [params.type]);
    return useForm<DeepNonNullable<PostFormData>>({
        defaultValues,
    });
};
```

![](https://cn-nb1.rains3.com/3rcd/media/1737194810255.png)

### URL后缀

默认的文章详情页是根据文章的`id`生成的URL后缀（如：`http://localhost:3000/posts/03eea18e-7472-40ea-9ae6-c4c07ebae548`），这样的URL对于SEO来说很不友好，而且毫无意义。在这节课的模型中，新增了一个`slug`字段，就可以自定义url了。同时，为了方便，增加一个功能，就是可以根据标题自动生成slug。这样就不需要每次手动输入一串`slug`了。为了避免中文URL，需要在自动生成时，把`slug`中的中文替换为拼音。下面，一步步实现这些功能

安装以下依赖

```bash
pnpm add pinyin segmentit
pnpm add @types/pinyin -D
```

编写一个`slug`生成函数，函数用于根据生成一个字符串的所有字母小写格式，它具有以下功能

1. 把传入的参数`from`这个字符串中的所有中文字转换为拼音
2. 使用用`-`符合拼接字符串的拼音词
3. 使用空格切割字符串为数组，然后遍历每个元素，把这些元素周边的空格全部去掉
4. 用`-`符合拼接字符串

```typescript
// src/libs/utils.ts
import { lowerCase, trim } from 'lodash';
import pinyin from 'pinyin';
// ...

/**
 * 把一个字符串的所有字符均转化为小写
 * 并使用"-"替换空格连接所有单词
 * 如果是汉字,则先转换为拼音后再进行以上操作
 * @param from
 */
export const generateLowerString = (from: string) => {
    const slug = pinyin(from, {
        style: 0,
        segment: false,
    })
        .map((words) => words[0])
        .join('-');
    return lowerCase(slug)
        .split(' ')
        .map((v) => trim(v, ' '))
        .join('-');
};
```

在表单中，调用上面的`generateLowerString`函数，添加一个根据标题生成`slug`的函数`generateTitleSlug`，并把该函数绑定到`slug`下面链接的点击事件上

```tsx
// src/app/_components/post/action-form.tsx
// ...
const generateTitleSlug: MouseEventHandler<HTMLAnchorElement> = useCallback(
    (e) => {
        e.preventDefault();
        if (!form.formState.isSubmitting) {
            const title = trim(form.getValues('title'), '');
            if (title) setSlug(generateLowerString(title));
        }
    },
    [form.formState.isSubmitting],
);

<Link
    className="tw-ml-5 tw-mr-1 tw-text-black dark:tw-text-white"
    href="#"
    onClick={generateTitleSlug}
    aria-disabled={form.formState.isSubmitting}
>
    [点此]
</Link>;
```

可以看到以下效果

![](https://cn-nb1.rains3.com/3rcd/media/1737196774176.gif)

有了`slug`后缀之后，就可以通过`slug`来查询文章。也就是说通过在url中传入`slug`来打开文章详情页。而`slug`我们是设置了可选字段的，所以在查询没有`slug`的文章时，还是需要通过`id`来找到的。添加两个文章查询方法，如下

```tsx
// src/app/actions/post.ts
// ...
/**
 * 根据id或slug查询文章信息
 * @param arg
 */
export const queryPostItem = async (arg: string): Promise<Post | null> => {
    const item = await db.post.findFirst({
        where: {
            OR: [
                { id: arg },
                {
                    slug: arg,
                },
            ],
        },
    });
    return item;
};

/**
 * 根据slug查询文章信息
 * @param slug
 */
export const queryPostItemBySlug = async (slug: string): Promise<Post | null> => {
    const item = await db.post.findUnique({ where: { slug } });
    return item;
};
```

接下来做以下更改

- 替换一下文章列表页（即首页）的文章访问连接
- 修改文章被创建或编辑更新后的跳转URL

:::success

文章编辑页和删除弹出框的读取就别更改了。因为在真实环境中这两功能需要登录后才能使用，对SEO页没多大意义，用`slug`反而失去了唯一性

:::

```tsx
// src/app/(pages)/page.tsx
// ...
<Link className={$styles.thumb} href={`/posts/${item.slug || item.id}`}>
  <Image
    src={item.thumb}
    alt={item.title}
    fill
    priority
    sizes="100%"
     // 如果使用bun,请务必加上这个,因为bun中启用远程图片优化会报错
    unoptimized
    />
</Link>

<div className={clsx($styles.title, 'tw-hover')}>
  <Link href={`/posts/${item.slug || item.id}`}>
    <h2 className="tw-ellips tw-animate-decoration tw-animate-decoration-lg">
      {item.title}
    </h2>
  </Link>
</div>

// src/app/_components/post/hooks.ts
// ...
// 创建或更新文章后跳转到文章详情页
// 注意,这里不要用push,防止在详情页后退后返回到创建或编辑页面的弹出框
if (!isNil(post)) router.replace(`/posts/${post.slug || post.id}`);
```

看一下效果

![](https://cn-nb1.rains3.com/3rcd/media/1737201550972.gif)

### 元数据

在页面中通过到处`metadata`常量或`generateMetadata`函数即可设置页面的基础SEO参数，具体可查看[next.js的metadata文档](https://nextjs.org/docs/app/building-your-application/optimizing/metadata)。当然，在真实的SEO环境中会涉及到OG图片、站点地图、RSS、rebots.txt以及站外提权等方方面面，这些留到后续的课程再讲解吧

说明一下下面的代码

- `metadata`常量仅用于甚至静态的SEO参数
- `generateMetadata`函数用于设置动态的SEO参数。比如从数据库中读取信息、从路由中获取参数等，所以是支持`async`异步的，甚至它还可以通过第二个`ResolvingMetadata`类型的参数获取父级页面或布局的`metadata`用于拼装当前页的SEO标题等

```tsx
// src/app/(pages)/layout.tsx
// ..
// 前面我们已经在布局中添加了SEO数据
export const metadata: Metadata = {
    title: 'pincman的博客',
    description:
        'pincman的个人博客,提供一些ts、react、node.js、php、golang相关的技术文档以及分享一些生活琐事',
};

// src/app/(pages)/posts/[item]/page.tsx
// ...
export const generateMetadata = async (
    { params }: { params: Promise<{ item: string }> },
    parent: ResolvingMetadata,
): Promise<Metadata> => {
    const { item } = await params;
    const post = await queryPostItem(item);

    if (isNil(post)) return {};

    return {
        title: `${post.title} - ${(await parent).title?.absolute}`,
        keywords: post.keywords,
        description: post.description,
    };
};

// src/app/(pages)/posts/create/page.tsx
// ...
export const generateMetadata = async (_: any, parent: ResolvingMetadata): Promise<Metadata> => {
    return {
        title: `创建文章 - ${(await parent).title?.absolute}`,
        description: '文章创建页面',
    };
};

// src/app/(pages)/posts/edit/[item]/page.tsx
// ...
export const generateMetadata = async (_: any, parent: ResolvingMetadata): Promise<Metadata> => {
    return {
        title: `编辑文章 - ${(await parent).title?.absolute}`,
        description: '文章编辑页面',
    };
};
```

给文章添加一些`关键字`和`描述信息`

![](https://cn-nb1.rains3.com/3rcd/media/1737202882756.png)

打开开发者工具，就可以看到SEO信息啦

![](https://cn-nb1.rains3.com/3rcd/media/1737202952529.png)

## 表单验证

目前，我们的表单并没有数据验证功能，这样很容易导致一些不需要的错误数据被保存。表单验证的库有很多，课程中选用shadcn/ui表单默认推荐的也是目前最流行的表单验证库： [zod][zod]

首先，安装此依赖

```bash
pnpm add zod
```

:::info

请注意：课程只是讲解怎么去使用这些生态和库，而不是把每个框架或库的所有API讲一遍，甚至next.js也是一样！所以，关于zod更详细的使用方法和其API，请查阅其[官网][zod]

:::

要使用zod对表单（对象）进行数据验证，必须先编写一个验证结构体

为了保证`slug`的唯一性，需要对`slug`进行数据库验证。我们使用`refine`添加了一个自定义规则，用于验证`slug`的唯一性，此规则遵守以下约定

- slug创建和编辑文章时，如果slug已经被占用且不是当前文章（编辑文章）的slug时，验证失败
- 在编辑文章时，如果slug已被占用，但是当前编辑的文章的slug，则不报错

为此，需要编写一个`uniqueValidator`验证器，此函数返回一个用于实现以上规则的唯一性验证的函数。返回函数的逻辑为

- 当表单的`slug`字段没有值的时候，那么通过验证。否则根据`slug`字段的值查询文章
- 如果没有与表单中`slug`的值相同的文章数据时，验证通过
- 在编辑文章时，会给这个函数传入一个当前编辑的文章的`id`。如果上面根据表单中的`slug`字段值查询出来的文章数据的`id`与当前编辑的文章`id`相同，就代表表单中的`slug`值就是当前编辑文章自己当前的`slug`值，并没有更新，所以验证也通过
- 除了以上，其它情况（创建文章时`slug`已存在，或更新文章时`slug`已存在且不与当前编辑的文章的`slug`值相同）都验证失败

编写完这个函数后，使用`uniqueValidator`升职`slugUnique`这个验证规则函数。然后通过`refine`在`slug`验证上加上这个验证规则

:::success

对于这种高频的API操作（这里指代数据库查询），其实可以加上防抖（在一定时间段内多次执行函数，只执行最后一次）函数，如lodash的`debounce`。这对减轻网络和数据库负担很有用！但是为了减轻课程应用的复杂度（目前还只是基础部分）以及`refine`的异步规则貌似自带防抖特性了，所以这里就不画蛇添足了

:::

以下是结构体代码

```typescript
// src/app/_components/post/form-validator.ts
import { queryPostItemBySlug } from '@/app/actions/post';
import { isNil } from 'lodash';
import { z } from 'zod';

/**
 * slug唯一性验证函数
 * @param id
 */
export const uniqueValidator = (id?: string) => async (val?: string) => {
    if (isNil(val) || !val.length) return true;
    const post = await queryPostItemBySlug(val);
    if (isNil(post) || post.id === id) return true;
    return false;
};

export const generatePostFormValidator = (id?: string) => {
    const slugUnique = uniqueValidator(id);
    return z
        .object({
            title: z
                .string()
                .min(1, {
                    message: '标题不得少于1个字符',
                })
                .max(200, {
                    message: '标题不得超过200个字符',
                }),
            body: z.string().min(1, {
                message: '标题不得少于1个字符',
            }),
            summary: z
                .string()
                .max(300, {
                    message: '摘要不得超过300个字符',
                })
                .optional(),
            slug: z
                .string()
                .max(250, {
                    message: 'slug不得超过250个字符',
                })
                .optional()
                .refine(slugUnique, {
                    message: 'slug必须是唯一的,请重新设置',
                }),
            keywords: z
                .string()
                .max(200, {
                    message: '描述不得超过200个字符',
                })
                .optional(),
            description: z
                .string()
                .max(300, {
                    message: '描述不得超过300个字符',
                })
                .optional(),
        })
        .strict();
};
```

把`PostFormData`换成验证结构的反射类型

```typescript
// src/app/_components/post/types.ts
import type { z } from 'zod';
import type { generatePostFormValidator } from './form-validator';
// ...
export type PostFormData = z.infer<ReturnType<typeof generatePostFormValidator>>;
```

为了使`react-form-hooks`可以使用`zod`进行验证，需要安装验证`react-form-hooks`和`zod`的整合器

```bash
pnpm add @hookform/resolvers
```

添加验证器到`react-form-hooks`的`useForm`中

:::info

通过更改`mode`来控制验证模式，`all`代表提交、实时输入等情况下都进行验证

:::

```typescript
// src/app/_components/post/types.ts
// ...
export const usePostActionForm = (params: { type: 'create' } | { type: 'update'; item: Post }) => {
    //...
    return useForm<DeepNonNullable<PostFormData>>({
        mode: 'all',
        resolver: zodResolver(
            generatePostFormValidator(params.type === 'update' ? params.item.id : undefined),
        ),
        defaultValues,
    });
};
```

看一下效果

![](https://cn-nb1.rains3.com/3rcd/media/1737203903840.png)

## 错误处理

现在我们的应用的错误处理还是使用next.js默认的页面。可以自定义一些错误页面，使得应用整体更加协调美观

### 404页面

定义一个404 not found页面。这会在找不到路由对应的页面或者主动执行`notFound`函数时显示。同样，这个404页面也可以分层级的，比如放在`src/app/not-found.tsx`和`src/app/(pages)/posts/not-found.tsx`下面是不同的，当访问`http://localhost:3000/posts/xxx`时，会优先显示后者，然后逐级往上查找，直到找到自定义的404页面为止。如果找不到，就显示默认的

我们这里定义两个notFound页面，分页用于`app`级别和`pages`级别，在`pages`级别下无需放入布局中的导航栏，因为已经在布局里了

:::note

后续我们在开发后台时，还需要重新编写一下`app`级别的notFound

:::

```tsx
// src/app/not-found.tsx
// ...
import $styles from './(pages)/layout.module.css';
const NotFoundPage: FC = () => (
    <Theme>
        <div className={$styles.layout}>
            <Header />
            <div className="tw-page-container">
                <div className="tw-page-blank">
                    <h2>Not Found</h2>
                    <span className="tw-mx-3">|</span>
                    <p>
                        404错误意味着这个页面已经不存在了,您可以
                        <b>
                            <Link className="tw-animate-decoration" href="/">
                                返回首页
                            </Link>
                        </b>
                    </p>
                </div>
            </div>
        </div>
    </Theme>
);

export default NotFoundPage;

// src/app/(pages)/not-found.tsx
// ...
const NotFoundPage: FC = () => (
    <div className="tw-page-container">
        <div className="tw-page-blank">
            <h2>Not Found</h2>
            <span className="tw-mx-3">|</span>
            <p>
                404错误意味着这个页面已经不存在了,您可以
                <b>
                    <Link className="tw-animate-decoration" href="/">
                        返回首页
                    </Link>
                </b>
            </p>
        </div>
    </div>
);

export default NotFoundPage;
```

修改css

```css
/* src/app/styles/tailwind/components.css */
/* ... */
/* 空白页样式,一般用于404和error页面 */
.tw-page-blank {
    @apply tw-bg-white/80 dark:tw-bg-black/50 tw-backdrop-blur-sm tw-h-full tw-w-full tw-drop-shadow-lg tw-rounded-md tw-flex tw-justify-center tw-items-center;
}
```

访问[http://localhost:3000/xxx](http://localhost:3000/xxx)会显示`app`级别下的NotFound，访问[http://localhost:3000/posts/xxx](http://localhost:3000/posts/xxx)会显示`pages`级别下的NotFound，它们的效果是一致的

![](https://cn-nb1.rains3.com/3rcd/media/1737209197345.png)

### 错误消息

对于404以外应用捕获的错误，在开发环境中next.js默认会显示一个红框，点击就可以看到错误。在生产环境中，会显示一个带有错误ID的白页。在这个应用中，我们把自定义的错误分为两种显示。对于操作类错误（如数据库操作），弹出一个消息框；而对于加载错误（如服务器数据读取等）显示错误页面

下面先来实现以下，消息框错误。消息框错误的弹出框使用shadcn的[toast][toast]组件实现

安装组件

```bash
pnpm addsc toast
```

修改页面布局，在布局中加入消息弹出框的`Provider`组件`Toaster`

```tsx
// src/app/(pages)/layout.tsx
// ...
const AppLayout: FC<PropsWithChildren<{ modal: ReactNode }>> = ({ children, modal }) => (
    <Theme>
        <div className={$styles.layout}>
            <Header />
            {children}
        </div>
        {modal}
        <Toaster />
    </Theme>
);
export default AppLayout;
```

修改组件抛出异常的组件或函数，在捕获错误时，添加`toast`消息框

```tsx
// src/app/_components/post/delete.tsx
// ...
export const PostDelete: FC<{ id: string }> = ({ id }) => {
    const router = useRouter();
    const { toast } = useToast();

     const deleteItem: MouseEventHandler<HTMLButtonElement> = useCallback(
        async (e) => {
            try {
                e.preventDefault();
                setPedding(true);
                await deletePostItem(id);
                setPedding(false);
                setOpen(false);
            } catch (error) {
                toast({
                    variant: 'destructive',
                    title: '删除失败',
                    description: (error as Error).message,
                });
            }

            // 删除文章后刷新页面
            router.refresh();
        },
        [id],
    );
    // ...
};

// src/app/_components/post/hooks.ts
// ...
export const usePostFormSubmitHandler = (
    params: { type: 'create' } | { type: 'update'; id: string },
) => {
    const router = useRouter();
    const { toast } = useToast();
    return useCallback(
        async (data: PostFormData) => {
            // ...
            } catch (error) {
                toast({
                    variant: 'destructive',
                    title: '遇到服务器错误,请联系管理员处理',
                    description: (error as Error).message,
                });
            }
        },
        [{ ...params }],
    );
};
```

现在，我们尝试在`updatePostItem`中抛出一个模拟异常看一下效果（**别忘记在测试效果后，把模拟异常代码去掉**）

```typescript
// src/app/actions/post.ts
// ...
export const updatePostItem = async (
    id: string,
    data: Partial<Omit<Post, 'id'>>,
): Promise<Post> => {
    throw new Error('表单提交错误，请稍后重试！');
    const item = await db.post.update({ where: { id }, data });
    return item;
};
```

![](https://cn-nb1.rains3.com/3rcd/media/1737209739445.gif)

### 错误页面

在渲染页面时，如果遇到错误，一般可以直接显示一个错误页。与`not-found.tsx`一样，`error.tsx`也是一个next.js预定义的页面名称。如果没定义此页面，遇到异常时，在开发环境中会直接显示一个红色的`Error`，而编译后的生产环境则显示一个空白页。另外，同样的，`error.tsx`也是层级优先的。下面，我们分别编写一个应用级别和页面界别的错误页面

:::warning

请注意：应用级别的错误页面不是指全局的`global-error.tsx`，目前我们为了简单，不需要定义全局的错误页面。就只当把应用级别的`error.tsx`当`global-error.tsx`用吧。有关更多的错误页面定义，请查看[官方文档](https://nextjs.org/docs/app/building-your-application/routing/error-handling)

:::

:::success

`error.tsx`必须是一个客户端组件

:::

```tsx
// src/app/error.tsx
'use client';
// ...
import $styles from './(pages)/layout.module.css';
const ErrorBoundaryPage: FC<{ error: Error & { digest?: string }; reset: () => void }> = ({
    error,
    reset,
}) => {
    const resetPage = useCallback<MouseEventHandler<HTMLAnchorElement>>((e) => {
        e.preventDefault();
        reset();
    }, []);
    return (
        <Theme>
            <div className={$styles.layout}>
                <Header />
                <div className="tw-page-container">
                    <div className="tw-page-blank  tw-flex tw-flex-col tw-space-y-4">
                        <h2>糟糕!服务器挂了...</h2>
                        <p>
                            错误信息: {error.message} |
                            <b className="tw-ml-3">
                                <Link
                                    className="tw-animate-decoration"
                                    passHref
                                    href="#"
                                    onClick={resetPage}
                                >
                                    点此重试
                                </Link>
                            </b>
                        </p>
                        <small className="tw-px-3">
                            如果是你自己的网络问题,修复后可.如果不是,请尽快联系管理员处理,十分感谢！
                        </small>
                    </div>
                </div>
            </div>
        </Theme>
    );
};
export default ErrorBoundaryPage;

// src/app/(pages)/error.tsx
('use client');
//...
const ErrorBoundaryPage: FC<{ error: Error & { digest?: string }; reset: () => void }> = ({
    error,
    reset,
}) => {
    const resetPage = useCallback<MouseEventHandler<HTMLAnchorElement>>((e) => {
        e.preventDefault();
        reset();
    }, []);
    return (
        <div className="tw-page-container">
            <div className="tw-page-blank  tw-flex tw-flex-col tw-space-y-4">
                <h2>糟糕!服务器挂了...</h2>
                <p>
                    错误信息: {error.message} |
                    <b className="tw-ml-3">
                        <Link
                            className="tw-animate-decoration"
                            passHref
                            href="#"
                            onClick={resetPage}
                        >
                            点此重试
                        </Link>
                    </b>
                </p>
                <small className="tw-px-3">
                    如果是你自己的网络问题,修复后可.如果不是,请尽快联系管理员处理,十分感谢！
                </small>
            </div>
        </div>
    );
};
export default ErrorBoundaryPage;
```

修改`queryPostItem`函数，模拟一个异常看一下效果（**别忘记在测试效果后，把模拟异常代码去掉**）

```typescript
// src/app/actions/post.ts
// ...
export const queryPostItem = async (arg: string): Promise<Post | null> => {
    throw new Error('数据加载错误，请稍后重试！');
    const item = await db.post.findFirst({
        where: {
            OR: [
                { id: arg },
                {
                    slug: arg,
                },
            ],
        },
    });
    return item;
};
```

效果如下

![](https://cn-nb1.rains3.com/3rcd/media/1737212538905.png)

## 骨架屏

在页面加载或操作数据时，用户会有一个等待时间。如果这个等待时间中，没有对用户进行任何反馈则会严重影响用户体验。在中后台这种spa系统加载时，我们尝尝会用一个加载中的中心旋转按钮来反馈用户，我们页面或数据正在加载中的状态。而前台则大概率会使用骨架屏。接下来，实现一下骨架屏反馈

这里简单的使用shadcn/ui的[skeleton骨架屏组件](https://ui.shadcn.com/docs/components/skeleton)编写加载中效果

安装组件

```bash
pnpm addsc skeleton
```

针对整个页面，使用页面级别的骨架屏。为了简单起见，我们直接让文章列表首页和文章展示页均显示一个骨架屏。不过细致化处理的话，这两个页面的内容显然是不一样的，应该是显示两个骨架屏的。而`loading.tsx`这个next.js预定义的加载组件并不是像`not-found.tsx`或`error.tsx`一样层级优先的，而是会多重展示。但是，如果你的页面中有调用`Suspense`来手动展示“加载中”效果，则next.js会自动使用`Suspense`来替代所有的`loading.tsx`

:::info

更多详细的loading规则，请自行查看next.js的[官网文档](https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming)

:::

由于以上`loading.tsx`的调用规则

1. 增加一个`PageSkeleton`组件，用于做大多数场景loading状态的骨架屏组件
2. 增加一个`PostContentSkeleton`组件，专门用于文章内容渲染中的骨架屏组件
3. 在`src/app/(pages)/posts`目录中添加一个`loading.tsx`，调用`PageSkeleton`组件，自动为文章详情、文章创建及编辑页面生成骨架屏
4. 在文章列表首页使用`Suspense`调用`PageSkeleton`手动加载骨架屏
5. 在水合组件组件中手动调用`PostContentSkeleton`。这样，在获取序列化文章内容并水合成功前会出骨架屏

注意：由于目前`generateMetadata`是会堵塞页面执行的，所以，骨架屏`loading.tsx`对于文章详情页和文章编辑页等需要通过fetch远程api从而动态生成meta数据的页面不会产生“数据加载中”的效果。其当前只能在数据加载完后闪一下，其实没任何意义。这节课中加进去仅为了演示效果，你也不可能为了这个效果而放弃SEO数据。这个问题[next.js官方的issue](https://github.com/vercel/next.js/issues/55524#issuecomment-2594024688)也正在解决中，后续我会持续关注。一旦有解决方案，我会在本节课中更新。而对于首页（即文章列表页），由于其`metadata`继承的布局的静态数据，所以，加上骨架屏是有意义的。会在远程数据获取前线上骨架屏

编写两个骨架屏组件

```tsx
// src/app/_components/post/skeleton.tsx
import type { FC } from 'react';

import { Skeleton } from '../shadcn/ui/skeleton';

/**
 * 通用骨架屏
 */
const PageSkeleton: FC = () => (
    <div className="tw-w-full tw-justify-center tw-space-y-7">
        <div className="tw-flex tw-flex-col tw-space-y-3">
            <Skeleton className="tw-h-52 tw-w-full" />
            <div className="tw-flex tw-h-16 tw-w-full tw-justify-between tw-space-x-20">
                <Skeleton className="tw-w-1/3 tw-flex-none tw-bg-gray-950/30 tw-backdrop-blur-sm" />
                <Skeleton className="tw-flex-auto  tw-bg-gray-950/30 tw-backdrop-blur-sm" />
            </div>
        </div>
        <div className="tw-flex tw-flex-col tw-space-y-5">
            <Skeleton className="tw-h-52 tw-w-full tw-backdrop-blur-md" />
            <div className="tw-flex tw-h-16 tw-w-full tw-justify-between tw-space-x-20">
                <Skeleton className="tw-w-1/3 tw-flex-none tw-bg-gray-950/30 tw-backdrop-blur-sm" />
                <Skeleton className="tw-flex-auto tw-bg-gray-950/30 tw-backdrop-blur-sm" />
            </div>
        </div>
    </div>
);

/**
 * 文章内容骨架屏
 */
const PostContentSkeleton: FC = () => (
    <div className="tw-flex tw-size-full tw-flex-auto tw-justify-between tw-space-x-2">
        <Skeleton className="tw-w-auto tw-flex-auto tw-bg-gray-950/30 tw-backdrop-blur-sm" />
        <Skeleton className="tw-hidden tw-bg-gray-950/30 tw-backdrop-blur-sm lg:tw-flex lg:tw-w-56" />
    </div>
);

export { PageSkeleton, PostContentSkeleton };
```

为文章详情页、文章创建页、文章编辑页添加预定义的`loading.tsx`以加载骨架屏

:::warning

就像前面说的，这里没有涉及数据加载，所以只在页面加载时瞬间显示一下

:::

```tsx
// src/app/(pages)/posts/loading.tsx
// ...
const PostLoadingPage: FC = () => (
    <div className="tw-page-container">
        <PageSkeleton />
    </div>
);
export default PostLoadingPage;
```

为文章列表首页添加`Suspense`，以手动加载`PageSkeleton`

```tsx
// src/app/(pages)/page.tsx
// ...
const HomePage: FC<{ searchParams: IPaginateQueryProps }> = async ({ searchParams }) => {
    // ...

        <div className="tw-page-container">
            <Suspense fallback={<PageSkeleton />}>
                {/* ... */}
            </Suspense>
        </div>
    );
};
```

为水合组件添加上骨架屏

```tsx
// src/app/_components/mdx/hydrate.tsx
// ...
export const MdxHydrate: FC<MdxHydrateProps> = (props) => {
    // ...
    return !isNil(content) ? (
        <div className={$styles.container}>
            <div className={$styles.article} ref={contentRef}>
                {header}
                {content}
            </div>
            {toc && <Toc serialized={serialized} isMobile={isMobile} />}
        </div>
    ) : (
        <PostContentSkeleton />
    );
};
```

为`queryPostPaginate`和`queryPostTotalPages`函数中添加一个模拟延迟加载器，使数据3秒后显示（**别忘记在测试效果后，把模拟延迟代码去掉**）

```typescript
// src/app/actions/post.ts
// ...
const loadingTime = () =>
    new Promise((r) => {
        setTimeout(() => {
            r(true);
        }, 3000);
    });

export const queryPostPaginate = async (
    options?: PaginateOptions,
): Promise<PaginateReturn<Post>> => {
    await loadingTime();
    //...
};

export const queryPostTotalPages = async (limit = 8): Promise<number> => {
    await loadingTime();
    //...
};
```

![](https://cn-nb1.rains3.com/3rcd/media/1737224601676.gif)

在`updatePostItem`中添加一个延迟3秒的操作函数（就是上面的`loadingTime`），然后选择编辑页面演示一下效果（**别忘记在测试效果后，把模拟延迟代码去掉**）

![](https://cn-nb1.rains3.com/3rcd/202408231310287.gif)

可以看到，上图的效果中，MD编辑器的文章内容框并没有被禁用。下面，我们来搞定一下这个内容框，使其在表单提交时，也同样变成禁用状态

修改`MarkdownEditorProps`类型，添加一个`disabled`的可选参数

```typescript
// src/app/_components/markdown/types.ts
// ...
export type MarkdownEditorProps = {
    disabled?: boolean;
    // ...
} & Record<string, any>;
```

修改`MarkdownEditor`组件，传入禁用参数

```tsx
// src/app/_components/post/action-form.tsx
// ...
export const MarkdownEditor: FC<MarkdownEditorProps> = forwardRef((props, _) => {
    // ...
    return (
        <MdEditor
            {...rest}
            editorId="markdown-editor"
            disabled={props.disabled ?? false}
            modelValue={content}
            onChange={setContent}
            pageFullscreen={pageFullscreen}
            ref={editorRef}
        />
    );
});
```

在表单中传入给`MarkdownEditor`禁用参数

```tsx
// src/app/_components/post/action-form.tsx
// ...
<FormField
    control={form.control}
    name="body"
    render={({ field }) => (
        <FormItem>
            <FormLabel>文章内容</FormLabel>
            <FormControl>
                <MarkdownEditor
                    {...field}
                    disabled={form.formState.isSubmitting}
                    content={body}
                    setContent={setBody}
                    handlers={editorScreenHandler}
                    previewTheme="arknights"
                />
            </FormControl>
            <FormMessage />
        </FormItem>
    )}
/>
```

为禁用后的编辑器添加一些样式，使禁用效果更明显

```css
/* src/app/_components/markdown/editor.module.css */
.editor {
    & :global(.cm-scroller) > div[contenteditable='false'] {
        @apply tw-relative tw-cursor-not-allowed;

        &::before {
            content: '';

            @apply tw-absolute tw-top-0 tw-left-0 tw-w-full tw-h-full tw-bg-white/45 tw-z-10;
        }
    }
}
```

在组件中添加`.editor`类

```tsx
// src/app/_components/markdown/editor.tsx
// ...
import $styles from './editor.module.css';

export const MarkdownEditor: FC<MarkdownEditorProps> = forwardRef((props, _) => {
    // ...
    return (
        <MdEditor
            {...rest}
            className={$styles.editor}
            // ...
        />
    );
});
```

看一下效果

![](https://cn-nb1.rains3.com/3rcd/202408231338029.gif)

由于文章创建页面的保持按钮是在表单外面的，所以需要通过像表单内传递一个改变外部状态的函数（如`setPadding`）来判断加载状态

修改`PostCreateFormProps`类型，添加一个可选的`setPedding`函数参数

```typescript
// src/app/_components/post/types.ts
// ...
export interface PostCreateFormProps {
    type: 'create';
    setPedding?: (value: boolean) => void;
}
```

修改表单，在`form.formState.isSubmitting`状态变化时，执行`setPedding`改变外部创建页面的状态

```tsx
// src/app/_components/post/action-form.tsx
// ...
export const PostActionForm = forwardRef<PostCreateFormRef, PostActionFormProps>((props, ref) => {
    // ...
    useEffect(() => {
        if (props.type === 'create' && !isNil(props.setPedding))
            props.setPedding(form.formState.isSubmitting);
    }, [form.formState.isSubmitting]);
});
```

现在可以在文章创建页面表单中，通过增加`pedding`状态和`setPedding`函数来判断状态，从而禁用“保存”按钮了

```tsx
// src/app/(pages)/posts/create/form.tsx
// ...
export const PostCreateForm: FC = () => {
    const ref = useRef<PostCreateFormRef | null>(null);
    const [pedding, setPedding] = useState(false);
    const changePadding = useCallback((value: boolean) => {
        setPedding(value);
    }, []);
    const createPost = useCallback<MouseEventHandler<HTMLButtonElement>>(async (e) => {
        e.preventDefault();
        ref.current?.create && (await ref.current?.create());
    }, []);
    return (
        <>
            <div className={$styles.actions}>
                <BackButton />
                <Button onClick={createPost} disabled={pedding}>
                    {pedding ? '保存中...' : '保存'}
                    <MdOutlineSave className="tw-ml-2" />
                </Button>
            </div>
            <PostActionForm ref={ref} type="create" setPedding={changePadding} />
        </>
    );
};
```

在`createPostItem`中添加一个延迟3秒的操作函数（就是上面的`loadingTime`），然后选择编辑页面演示一下效果（**别忘记在测试效果后，把模拟延迟代码去掉**）

![](https://cn-nb1.rains3.com/3rcd/202408231354637.gif)

给删除按钮也添加一个处理中效果。原理都差不多，就不做过多解释了，直接上代码（别忘了给`deletePostItem`函数添加延时函数，方便测试效果）

:::info

必须改变了“取消”和“确认”两个按钮的默认事件，通过状态来空。否则延迟加载不生效（因为默认事件是在点击确认后会立马关闭弹出框）

:::

```tsx
// src/app/_components/post/delete.tsx
// ...

export const PostDelete: FC<{ id: string }> = ({ id }) => {
    // ...
    const [open, setOpen] = useState(false);
    const [pedding, setPedding] = useState(false);

    const changeOpen = useCallback((value: boolean) => {
        setOpen(value);
    }, []);

    const close: MouseEventHandler<HTMLButtonElement> = useCallback((e) => {
        e.preventDefault();
        if (!pedding) setOpen(false);
    }, []);

    const deleteItem: MouseEventHandler<HTMLButtonElement> = useCallback(
        async (e) => {
            e.preventDefault();
            try {
                setPedding(true);
                await deletePostItem(id);
                setPedding(false);
                setOpen(false);
            } catch (error) {
                // ...
            }
            // 删除文章后刷新页面
            router.refresh();
        },
        [id],
    );
    return (
        <AlertDialog open={open} onOpenChange={changeOpen}>
            {/* ... */}
            <AlertDialogContent onEscapeKeyDown={(event) => event.preventDefault()}>
                {/* ... */}
                <AlertDialogFooter>
                    <AlertDialogCancel disabled={pedding} onClick={close}>
                        取消
                    </AlertDialogCancel>
                    <AlertDialogAction onClick={deleteItem} disabled={pedding}>
                        {pedding ? '删除中' : '确认'}
                    </AlertDialogAction>
                </AlertDialogFooter>
            </AlertDialogContent>
        </AlertDialog>
    );
};
```

![](https://cn-nb1.rains3.com/3rcd/202408231416141.gif)

## 清理工作

最后，把`loadingTime`函数以及所有使用到`loadingTime`函数的代码都删除掉。另外，前面错误页面的一些用于测试的`throw new`请全部删除掉，以免应用出错
